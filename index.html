<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>通信指令観測システム</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=M+PLUS+1p:wght@400;500;700&display=swap" rel="stylesheet">
<style>
@font-face {
  font-family: 'DSEG7';
  src: url('DSEG7ClassicMini-Bold.woff') format('woff');
}
:root{
  --bg-primary:#1a1a1a;
  --bg-secondary:#242424;
  --bg-tertiary:#2e2e2e;
  --border:#3a3a3a;
  --text-primary:#e0e0e0;
  --text-secondary:#a0a0a0;
  --text-muted:#707070;
  --accent-blue:#e0e0e0;
  --accent-cyan:#e0e0e0;
  --lv1:#4caf50;
  --lv2:#ff9800;
  --lv3:#f44336;
  --lv4:#9c27b0;
}
html, body {
  height: 100%;
  margin: 0;
  overflow: hidden;
}
*{box-sizing:border-box}
body{
  background:var(--bg-primary);
  color:var(--text-primary);
  font:14px/1.6 'M PLUS 1p', sans-serif;
  display: grid;
  grid-template-rows: auto auto 1fr; /* ヘッダー(auto), 操作パネル(auto), メイン(残り全部) */
}
.system-header{
  background:var(--bg-secondary);
  border-bottom:2px solid var(--border);
  padding:16px 24px;
}
.header-row{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:20px;
  flex-wrap:wrap;
}
.system-title{
  font-size:18px;
  font-weight:700;
  color:var(--accent-cyan);
  letter-spacing:1px;
  text-transform:uppercase;
}
.system-clock{
  font-size:20px;
  font-weight:700;
  color:var(--lv2); /* 色を変更 */
  font-family:'DSEG7', monospace;
  letter-spacing:0.5px;
}
.system-status {
  display: none;
}
.control-panel{
  background:var(--bg-secondary);
  border-bottom:1px solid var(--border);
  padding:12px 24px;
  transition: all 0.3s ease-in-out; /* トグル時のアニメーション */
}
.control-panel.hidden {
  height: 0;
  padding-top: 0;
  padding-bottom: 0;
  border: none;
  overflow: hidden;
}
.control-row{
  display:flex;
  align-items:center;
  gap:12px;
  flex-wrap:wrap;
}
.btn{
  padding:8px 20px;
  background:var(--bg-tertiary);
  border:1px solid var(--border);
  border-radius:4px;
  color:var(--text-primary);
  font:12px/1.4 'M PLUS 1p', sans-serif;
  font-weight:500;
  cursor:pointer;
  transition:all 0.2s;
  letter-spacing:0.5px;
  text-transform:uppercase;
}
.btn:hover{
  background:var(--bg-primary);
  border-color:var(--accent-blue);
  color:var(--accent-blue);
}
.btn.primary{
  background:var(--accent-blue);
  border-color:var(--accent-blue);
  color:#000;
  font-weight:700;
}
.btn.active{
  background:var(--accent-cyan);
  border-color:var(--accent-cyan);
  color:#000;
  font-weight:700;
}
.location-input{
  padding: 8px 12px;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--text-primary);
  font: 12px/1.4 'M PLUS 1p', sans-serif;
  min-width: 160px;
  height: 34px;
}
.location-input:focus{
  outline:none;
  border-color:var(--accent-blue);
}
select{
  padding:8px 12px;
  background:var(--bg-tertiary);
  border:1px solid var(--border);
  border-radius:4px;
  color:var(--text-primary);
  font:12px/1.4 'M PLUS 1p', sans-serif;
  cursor:pointer;
  min-width:200px;
}
.main-content{
  display:grid;
  grid-template-columns:400px 1fr;
  gap:0;
  overflow: hidden;
}
.case-panel{
  background:var(--bg-secondary);
  border-right:2px solid var(--border);
  display:flex;
  flex-direction:column;
  min-height: 0;
}
.panel-header{
  padding:16px 20px;
  border-bottom:1px solid var(--border);
  background:var(--bg-tertiary);
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.panel-title{
  font-size:13px;
  font-weight:700;
  color:var(--accent-cyan);
  letter-spacing:1px;
  text-transform:uppercase;
}
.rate-slider{
  display:flex;
  align-items:center;
  gap:10px;
  padding:8px 16px;
  background:var(--bg-tertiary);
  border:1px solid var(--border);
  border-radius:4px;
}
.rate-slider label{
  font-size:11px;
  color:var(--text-muted);
  letter-spacing:0.5px;
}
.rate-slider input[type="range"]{
  -webkit-appearance: none;
  appearance: none;
  width:100px;
  height:4px;
  background:var(--border);
  outline:none;
  border-radius:2px;
}
.rate-slider input[type="range"]::-webkit-slider-thumb{
  -webkit-appearance: none;
  appearance: none;
  width:16px;
  height:16px;
  background:var(--accent-blue);
  border-radius:50%;
  cursor:pointer;
}
.rate-slider .value{
  font-weight:700;
  color:var(--accent-blue);
  min-width:35px;
  text-align:right;
}
.case-list{
  flex:1;
  overflow-y:auto;
  overflow-x:hidden;
  padding-bottom:20px;
}
.case-card{
  padding:16px 20px;
  border-bottom:1px solid var(--border);
  transition:background 0.2s;
}
.case-card:hover{
  background:var(--bg-tertiary);
}
.case-header{
  display:flex;
  align-items:center;
  gap:10px;
  margin-bottom:8px;
}
.level-badge{
  padding:4px 10px;
  border-radius:3px;
  font-size:11px;
  font-weight:700;
  letter-spacing:0.5px;
}
.level-badge.lv1{background:var(--lv1);color:#000}
.level-badge.lv2{background:var(--lv2);color:#000}
.level-badge.lv3{background:var(--lv3);color:#fff}
.level-badge.lv4{background:var(--lv4);color:#fff}
.case-id{
  font-size:13px;
  font-weight:700;
  color:var(--accent-blue);
}
.case-type{
  font-size:12px;
  color:var(--text-primary);
  margin-left:auto;
}
.case-body{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:8px;
  font-size:11px;
  color:var(--text-secondary);
}
.case-info-row{
  display:flex;
  gap:6px;
}
.info-label{
  color:var(--text-muted);
}
.info-value{
  color:var(--text-secondary);
  font-weight:500;
}
.case-footer{
  margin-top:8px;
  padding-top:8px;
  border-top:1px solid var(--border);
  display:flex;
  justify-content:space-between;
  align-items:center;
  font-size:11px;
}
.case-units{
  color:var(--accent-cyan);
  font-weight:500;
}
.case-time, .msg-time{
  color:var(--text-muted);
  font-family:'M PLUS 1p', sans-serif;
}
.radio-panel{
  background:var(--bg-primary);
  display:flex;
  flex-direction:column;
  min-height: 0;
}
.radio-log{
  flex:1;
  overflow-y:auto;
  overflow-x:hidden;
  padding:12px;
  padding-bottom:40px;
}
.radio-message{
  display:flex;
  flex-direction:column;
  gap:6px;
  padding:12px 16px;
  margin-bottom:8px;
  background:var(--bg-secondary);
  border-left:3px solid transparent;
  border-radius:4px;
  transition:all 0.2s;
  opacity:0;
  transform:translateY(10px);
  animation:slideIn 0.3s ease-out forwards;
}
@keyframes slideIn{
  to{
    opacity:1;
    transform:translateY(0);
  }
}
.radio-message:hover{
  background:var(--bg-tertiary);
  border-left-color:#808080;
}
.radio-message-meta{
  display:flex;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
}
.msg-level{
  padding:4px 8px;
  border-radius:3px;
  font-size:11px;
  font-weight:700;
  text-align:center;
  letter-spacing:0.5px;
  color:var(--text-muted);
}
.msg-case{
  font-size:11px;
  font-weight:700;
  color:var(--text-muted);
}
.msg-content{
  font:13px/1.7 'M PLUS 1p', sans-serif;
  color:var(--text-primary);
  word-break:break-word;
  padding-top:4px;
}
.no-cases{
  padding:40px 20px;
  text-align:center;
  color:var(--text-muted);
  font-size:12px;
}
::-webkit-scrollbar{width:8px;height:8px}
::-webkit-scrollbar-track{background:var(--bg-primary)}
::-webkit-scrollbar-thumb{background:var(--border);border-radius:4px}
::-webkit-scrollbar-thumb:hover{background:var(--text-muted)}
@media (max-width: 768px) {
  .main-content{
    grid-template-columns:1fr;
    grid-template-rows:auto 1fr;
  }
  .case-panel{
    border-right:none;
    border-bottom:2px solid var(--border);
    max-height:35vh;
  }
}
</style>
</head>
<body>

<div class="system-header">
  <div class="header-row">
    <div class="system-title" id="systemTitle">通信指令観測システム（CSV駆動版）</div>
    <div class="system-clock" id="jst">--:--:--.-- JST</div>
    <div class="system-status" id="status">STANDBY</div>
    <button id="toggleControls" class="btn">操作パネル</button>
  </div>
</div>

<div class="control-panel" id="controlPanel">
  <div class="control-row">
    <input type="text" id="locationInput" class="location-input" value="本部">
    <button id="syncBtn" class="btn primary" disabled>システム起動</button>
    <button id="ttsToggle" class="btn">音声: OFF</button>
    <select id="voiceSel"><option value="">音声自動選択</option></select>
    <div class="rate-slider">
      <label>速度:</label>
      <input type="range" id="rateSlider" min="0.5" max="2.0" step="0.1" value="1.2">
      <span class="value" id="rateValue">1.2</span>X
    </div>
  </div>
</div>

<div class="main-content">
  <div class="case-panel">
<div class="panel-header">
  <div class="panel-title">進行中の事案</div>
</div>
    <div class="case-list" id="caseList">
      <div class="no-cases">CSVファイルを読み込んでください</div>
    </div>
  </div>

  <div class="radio-panel">
    <div class="radio-log" id="log"></div>
  </div>
</div>

<script>
// グローバル変数
const FIXED_SEED = "kitakyu2025";
const BASE_CPS = 12;
let locationName = "本部";
let TTS_ENABLED = false;
let chosenVoice = null;
let ttsRate = 1.5;
let audioCtx = null;
let scenarioLoader = null;
let scenarioEngine = null;
let runningToken = 0;
let tickTimer = null;
let userScrolling = false;
let scrollTimeout = null;

// ==========================================
// シナリオCSVローダー
// ==========================================

class ScenarioLoader {
  constructor() {
    this.paramLists = {};
    this.scenarios = [];
    this.scenarioMap = new Map();
  }

  parseCSV(csvText) {
    const lines = csvText.split('\n').filter(line => {
      const trimmed = line.trim();
      return trimmed && !trimmed.startsWith('#');
    });

    let currentLevel = null;
    let currentScenario = null;
    const nodeStack = [];

    for (let i = 1; i < lines.length; i++) {
      const line = lines[i];
      const [section, id, condition, probability, phase, message, params] = 
        this.parseCSVLine(line);

      if (section === 'PARAM') {
        this.paramLists[id] = params ? params.split(';').map(s => s.trim()) : [];
      } 
      else if (section === 'LEVEL') {
        currentLevel = { level: id, scenarios: [] };
        this.scenarios.push(currentLevel);
        nodeStack.length = 0;
      }
      else if (section === 'NAME') {
        const paramsObj = this.parseParams(params);
        currentScenario = {
          name: id,
          type: paramsObj.type || 'unknown',
          level: parseInt(paramsObj.level) || 1,
          probability: 0,
          rootNodes: []
        };
        currentLevel.scenarios.push(currentScenario);
        this.scenarioMap.set(paramsObj.type, currentScenario);
        nodeStack.length = 0;
      }
      else if (section === 'NODE') {
        const depth = this.getIndentDepth(line);
        const node = {
          id: id.trim(),
          depth,
          condition,
          probability: parseFloat(probability) || 1.0,
          phase,
          message,
          params: this.parseParams(params),
          children: []
        };

        if (condition === 'new_case') {
          currentScenario.probability = node.probability;
        }

        while (nodeStack.length > 0 && nodeStack[nodeStack.length - 1].depth >= depth) {
          nodeStack.pop();
        }

        if (nodeStack.length === 0) {
          currentScenario.rootNodes.push(node);
        } else {
          nodeStack[nodeStack.length - 1].children.push(node);
        }

        nodeStack.push(node);
      }
    }
  }
  
  parseCSVLine(line) {
    const regex = /(?:^|,)(\"(?:[^\"]+|\"\")*\"|[^,]*)/g;
    const result = [];
    let match;
    while (match = regex.exec(line)) {
      let value = match[1];
      if (value.startsWith('"') && value.endsWith('"')) {
        value = value.substring(1, value.length - 1).replace(/""/g, '"');
      }
      result.push(value.trim());
    }
    
    if (line.endsWith(',')) {
        result.push('');
    }

    while (result.length < 7) {
      result.push('');
    }

    return result;
  }

  getIndentDepth(line) {
    const match = line.match(/^(\s*)/);
    if (!match) return 0;
    return Math.floor(match[1].length / 2);
  }

  parseParams(paramsStr) {
    if (!paramsStr) return {};
    const pairs = paramsStr.split(';').filter(p => p.trim());
    const result = {};
    for (const pair of pairs) {
      const [key, value] = pair.split('=').map(s => s.trim());
      if (key && value) {
        result[key] = value;
      }
    }
    return result;
  }

  async loadFromFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          this.parseCSV(e.target.result);
          resolve();
        } catch (error) {
          reject(error);
        }
      };
      reader.onerror = reject;
      reader.readAsText(file);
    });
  }
}

// ==========================================
// メッセージパーサー
// ==========================================

class MessageParser {
  constructor(paramLists) {
    this.paramLists = paramLists;
  }

  parse(template, context, seed) {
    let result = template;
    let lastResult = '';

    while (result !== lastResult) {
        lastResult = result;

        result = result.replace(/\{([^}#]+\/[^}]+)\}/g, (match, items) => {
          const choices = items.split('/').map(s => s.trim());
          const index = Math.floor(this.rand01(seed, 'inline', match) * choices.length);
          return choices[index];
        });

        result = result.replace(/\{#(\w+):(\d+)-(\d+)\}/g, (match, name, min, max) => {
          const minVal = parseInt(min);
          const maxVal = parseInt(max);
          return Math.floor(this.rand01(seed, name, match) * (maxVal - minVal + 1)) + minVal;
        });

        result = result.replace(/\{#(\w+)\}/g, (match, name) => {
          if (name === 'num') {
            return Math.floor(this.rand01(seed, 'num', match) * 3) + 1;
          }
          if (name === 'eta') {
            return Math.floor(this.rand01(seed, 'eta', match) * 9) + 2;
          }
          if (this.paramLists[name]) {
            const list = this.paramLists[name];
            const index = Math.floor(this.rand01(seed, name, match) * list.length);
            return list[index];
          }
          return match;
        });

        result = result.replace(/\{(\w+)\}/g, (match, key) => {
          const value = context[key];
          return (value !== undefined && value !== null) ? value : '';
        });
    }

    result = result.replace(/\{([^{}]+)\}/g, (match, content) => content);
    result = result.replace(/、\s*、/g, '、').replace(/、$/g, '');

    return result;
  }

  rand01(seed, ...keys) {
    const str = [seed, ...keys].join('|');
    let h = 2166136261 >>> 0;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    h = h >>> 0;
    let t = h;
    t += 0x6D2B79F5;
    let x = Math.imul(t ^ t >>> 15, 1 | t);
    x ^= x + Math.imul(x ^ x >>> 7, 61 | x);
    return ((x ^ x >>> 14) >>> 0) / 4294967296;
  }
}

// ==========================================
// シナリオエンジン
// ==========================================

class ScenarioEngine {
  constructor(loader, seed, unitTypes) {
    this.loader = loader;
    this.seed = seed;
    this.parser = new MessageParser(loader.paramLists);
    this.unitTypes = unitTypes;
    this.activeCases = new Map();
    this.caseIdCounter = 1;
  }

  evaluateCondition(condition, caseState) {
    if (!condition) return false;
    switch (condition) {
      case 'new_case': return caseState.isNew;
      case 'awaiting_response': return caseState.awaitingResponse;
      case 'default': return true;
      case 'has_units': return caseState.hasAvailableBackupUnits;
      default:
        if (condition.startsWith('rand<')) {
          const threshold = parseFloat(condition.substring(5));
          return this.parser.rand01(this.seed, 'condition', caseState.id, caseState.elapsed) < threshold;
        }
        return false;
    }
  }

  selectNextNode(currentNode, caseState) {
    const candidates = currentNode.children.filter(child => {
      const conditionMet = this.evaluateCondition(child.condition, caseState);
      const probabilityMet = this.parser.rand01(this.seed, 'select', child.id, caseState.id) < child.probability;
      return conditionMet && probabilityMet;
    });
    if (candidates.length === 0) {
      return currentNode.children.find(child => child.condition === 'default') || null;
    }
    return candidates[0];
  }

  generateNewCase(n, busyUnits) {
    const allScenarios = this.loader.scenarios.flatMap(level => level.scenarios);
    const totalWeight = allScenarios.reduce((sum, s) => sum + s.probability, 0);
    const r = this.parser.rand01(this.seed, 'scenario', n) * totalWeight;
    let cumulative = 0;
    let selectedScenario = allScenarios[0];
    for (const scenario of allScenarios) {
      cumulative += scenario.probability;
      if (r <= cumulative) {
        selectedScenario = scenario;
        break;
      }
    }

    const scenarioType = selectedScenario.type;
    let unitTypeKey;
    if (['suspicious_object', 'demonstration'].includes(scenarioType)) {
        unitTypeKey = 'backup';
    } else if (['traffic_violation', 'parking_violation', 'traffic_accident', 'hit_and_run'].includes(scenarioType)) {
        unitTypeKey = 'traffic';
    } else if (['patrol', 'suspicious'].includes(scenarioType)) {
        unitTypeKey = 'patrol';
    } else {
        unitTypeKey = 'investigation';
    }
    
    const unitPool = this.unitTypes[unitTypeKey] || [];
    const availableUnitsForCase = unitPool.filter(u => !busyUnits.has(u));
    if (availableUnitsForCase.length === 0) return null;
    
    const unit = availableUnitsForCase[Math.floor(this.parser.rand01(this.seed, 'unit', n) * availableUnitsForCase.length)];
    const zoneList = this.loader.paramLists.zones || [];
    const zone = zoneList[Math.floor(this.parser.rand01(this.seed, 'zone', n) * zoneList.length)];
    const caseId = `C${String(this.caseIdCounter++).padStart(4, '0')}`;
    const firstNode = selectedScenario.rootNodes[0];
    
    const caseObj = {
      id: caseId, scenario: selectedScenario, currentNode: firstNode,
      zone, unit, backupUnits: [], level: selectedScenario.level,
      startTime: Date.now(), awaitingResponse: true, phase: firstNode.phase,
      isVisible: false
    };

    if (firstNode.params && firstNode.params.add_units) {
        const newUnits = firstNode.params.add_units.split(';');
        newUnits.forEach(unitName => {
            if (!caseObj.backupUnits.includes(unitName)) {
                caseObj.backupUnits.push(unitName);
            }
        });
    }

    this.activeCases.set(caseId, caseObj);
    const context = { unit, zone, type_ja: selectedScenario.name };
    let message = this.parser.parse(firstNode.message, context, this.seed + n);
    message = message.replace(/本部/g, locationName);
    
    return {
      id: `N${String(n).padStart(6, '0')}`, caseId, level: selectedScenario.level,
      phase: firstNode.phase, zone, unit, message, scenarioName: selectedScenario.name
    };
  }

  progressCase(caseId, n, busyUnits) {
    const caseObj = this.activeCases.get(caseId);
    if (!caseObj) return null;

    const availableBackupUnits = (this.unitTypes.backup || []).filter(u => !busyUnits.has(u));
    const caseState = {
      id: caseId, isNew: false, awaitingResponse: caseObj.awaitingResponse,
      elapsed: Math.floor((Date.now() - caseObj.startTime) / 1000),
      hasAvailableBackupUnits: availableBackupUnits.length > 0
    };

    const nextNode = this.selectNextNode(caseObj.currentNode, caseState);

    if (!nextNode) {
      if (caseObj.awaitingResponse) {
        caseObj.awaitingResponse = false;
        return null; 
      }
      if (caseObj.phase !== 'clear') {
        caseObj.phase = 'clear';
        setTimeout(() => this.activeCases.delete(caseId), 5000);
      }
      return null;
    }

    caseObj.currentNode = nextNode;
    caseObj.phase = nextNode.phase;
    caseObj.awaitingResponse = (nextNode.condition === 'awaiting_response');

    if (nextNode.params && nextNode.params.add_units) {
        const newUnits = nextNode.params.add_units.split(';');
        newUnits.forEach(unitName => {
            if (!caseObj.backupUnits.includes(unitName) && caseObj.unit !== unitName) {
                caseObj.backupUnits.push(unitName);
            }
        });
    }

    let backupUnit = null;
    if (nextNode.phase === 'backup_response' && availableBackupUnits.length > 0) {
      backupUnit = availableBackupUnits[0];
      caseObj.backupUnits.push(backupUnit);
    }

    const context = {
      unit: caseObj.unit, zone: caseObj.zone, type_ja: caseObj.scenario.name,
      backup_unit: backupUnit
    };
    
    let message = this.parser.parse(nextNode.message, context, this.seed + n);
    message = message.replace(/本部/g, locationName);

    return {
      id: `N${String(n).padStart(6, '0')}`, caseId, level: caseObj.level,
      phase: nextNode.phase, zone: caseObj.zone,
      unit: backupUnit || caseObj.unit, message, scenarioName: caseObj.scenario.name
    };
  }

  getAllActiveCases() {
    return Array.from(this.activeCases.values()).filter(c => c.phase !== 'clear');
  }
  
  getVisibleCases() {
      return this.getAllActiveCases().filter(c => c.isVisible);
  }
}

// ==========================================
// UI更新
// ==========================================
function updateCaseStatus() {
  const el = document.getElementById("caseList");
  if (!scenarioEngine) {
    el.innerHTML = '<div class="no-cases">CSVファイルを読み込んでください</div>';
    return;
  }
  
  const active = scenarioEngine.getVisibleCases();
  if (active.length === 0) {
    el.innerHTML = '<div class="no-cases">現在、進行中の事案はありません</div>';
    return;
  }

  active.sort((a, b) => b.level - a.level);
  el.innerHTML = active.map(c => {
    const t = Math.floor((Date.now() - c.startTime) / 1000);
    const m = Math.floor(t / 60), s = t % 60;
    const allUnits = [c.unit, ...c.backupUnits];
    const unitsStr = allUnits.slice(0, 2).join('・ ') + (allUnits.length > 2 ? ` 他${allUnits.length - 2}台` : '');
    const levelClass = `lv${c.level}`;
    const phaseMap = {
      dispatch: '出動指令', enroute: '現場向け', on_scene: '現場対応中',
      backup: '応援要請', backup_response: '応援出動', escalate: 'エスカレート',
      escape: '逃走追跡', arrest: '容疑者確保', negotiation: '交渉中',
      assault: '強行突入', special_request: '特殊部隊要請', clear: '処理完了'
    };
    return `<div class="case-card">
      <div class="case-header">
        <span class="level-badge ${levelClass}">LV${c.level}</span>
        <span class="case-id">${c.id}</span>
        <span class="case-type">${c.scenario.name}</span>
      </div>
      <div class="case-body">
        <div class="case-info-row"><span class="info-label">地区:</span><span class="info-value">${c.zone}</span></div>
        <div class="case-info-row"><span class="info-label">状態:</span><span class="info-value">${phaseMap[c.phase] || c.phase}</span></div>
      </div>
      <div class="case-footer">
        <span class="case-units">${unitsStr}</span>
        <span class="case-time">${m}:${String(s).padStart(2, '0')}</span>
      </div>
    </div>`;
  }).join('');
}

// ==========================================
// ユーティリティ
// ==========================================

const sleep = ms => new Promise(r => setTimeout(r, ms));

async function typeOut(seed, cpsBase, ev, msgEl) {
  const pauses = { ",": 120, "、": 160, ".": 180, "。": 220, " ": 50 };
  const base = 1000 / cpsBase;
  msgEl.textContent = "";

  for (let i = 0; i < ev.message.length; i++) {
    const ch = ev.message[i];
    let extra = pauses[ch] || 0;
    await sleep(base + extra);
    msgEl.textContent += ch;
  }
}

// ==========================================
// 時報音（音声ONの時のみ）
// ==========================================

function ensureAudio() {
  if (!audioCtx)
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === "suspended")
    audioCtx.resume();
}

function toneNTT(kind) {
  if (!TTS_ENABLED || !audioCtx) return;
  const p = {
    pip: { f: 2000, dur: 40, g: 0.03, atk: 0.004, dec: 0.030, rel: 0.030, h2: 0.18 },
    pop: { f: 500, dur: 100, g: 0.06, atk: 0.006, dec: 0.050, rel: 0.060, h2: 0.20 },
    peen: { f: 1000, dur: 600, g: 0.06, atk: 0.008, dec: 0.200, rel: 0.300, h2: 0.25 }
  }[kind];

  const ctx = audioCtx, t0 = ctx.currentTime;
  const osc = ctx.createOscillator(); osc.type = 'square'; osc.frequency.value = p.f;
  const gain = ctx.createGain(); gain.gain.value = 0;
  const filter = ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = p.f * 1.4;
  osc.connect(filter); filter.connect(gain); gain.connect(ctx.destination);

  const g = gain.gain;
  g.setValueAtTime(0, t0);
  g.linearRampToValueAtTime(p.g, t0 + p.atk);
  g.linearRampToValueAtTime(p.g * 0.8, t0 + p.atk + p.dec);
  g.linearRampToValueAtTime(0.0001, t0 + (p.dur / 1000) + p.rel);

  osc.start(t0);
  osc.stop(t0 + (p.dur / 1000) + p.rel + 0.05);
}

function startTimeSignal() {
  if (tickTimer) clearInterval(tickTimer);
  if (!TTS_ENABLED) return;
  
  ensureAudio();
  tickTimer = setInterval(() => {
    if (!TTS_ENABLED) return;
    const s = new Date().getSeconds();
    if (s % 10 === 0) { toneNTT('peen'); return; }
    if (s === 57 || s === 58 || s === 59) { toneNTT('pop'); return; }
    toneNTT('pip');
  }, 1000);
}

function stopTimeSignal() {
  if (tickTimer) {
    clearInterval(tickTimer);
    tickTimer = null;
  }
}

// ==========================================
// 時計
// ==========================================

(function () {
  const el = document.getElementById("jst");
  function pad(n, len = 2) { return String(n).padStart(len, "0"); }
  function tick() {
    const now = new Date();
    const ms = String(now.getMilliseconds()).padStart(3, '0');
    el.textContent = `${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}.${ms}`;
  }
  tick();
  setInterval(tick, 50); // 更新間隔を短縮してミリ秒を表示
})();

// ==========================================
// 自動スクロール制御
// ==========================================

(function() {
  const log = document.getElementById("log");
  
  log.addEventListener('wheel', () => {
    userScrolling = true;
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => { userScrolling = false; }, 2000);
  });
  
  log.addEventListener('touchstart', () => { userScrolling = true; });
  
  log.addEventListener('touchend', () => {
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => { userScrolling = false; }, 2000);
  });
  
  log.addEventListener('mousedown', (e) => {
    if (e.offsetX > log.clientWidth) { userScrolling = true; }
  });
  
  log.addEventListener('mouseup', () => {
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => { userScrolling = false; }, 2000);
  });
})();

// ==========================================
// 音声（簡易版）
// ==========================================

function loadVoices() {
  if (!('speechSynthesis' in window)) return;
  const load = () => {
    const vs = speechSynthesis.getVoices();
    const sel = document.getElementById("voiceSel");
    sel.innerHTML = '<option value="">Auto Select</option>';
    vs.forEach((v, i) => {
      const o = document.createElement('option');
      o.value = String(i); o.textContent = `${v.name} (${v.lang})`;
      sel.appendChild(o);
    });
    const jaVoice = vs.find(v => /^ja/i.test(v.lang)) || vs[0];
    chosenVoice = jaVoice;
  };
  load();
  speechSynthesis.onvoiceschanged = load;
}
loadVoices();

document.getElementById("voiceSel").addEventListener('change', () => {
  const vs = speechSynthesis.getVoices();
  const i = parseInt(document.getElementById("voiceSel").value);
  chosenVoice = Number.isInteger(i) ? vs[i] : vs.find(v => /^ja/i.test(v.lang));
});

document.getElementById("rateSlider").addEventListener('input', (e) => {
  ttsRate = parseFloat(e.target.value);
  document.getElementById("rateValue").textContent = ttsRate.toFixed(1);
});

async function speakMessage(text) {
  if (!TTS_ENABLED || !('speechSynthesis' in window)) return;
  
  const utter = new SpeechSynthesisUtterance(text);
  utter.lang = chosenVoice?.lang || 'ja-JP';
  utter.voice = chosenVoice || null;
  utter.rate = ttsRate;
  utter.pitch = 1.0;
  utter.volume = 1.0;

  return new Promise((resolve) => {
    utter.onend = resolve;
    utter.onerror = resolve;
    try {
      if (speechSynthesis.speaking) speechSynthesis.cancel();
      speechSynthesis.speak(utter);
    } catch {
      resolve();
    }
  });
}

// ==========================================
// メインループ
// ==========================================

async function runSystem() {
  if (!scenarioEngine) {
    alert('CSVファイルを先に読み込んでください');
    return;
  }

  const status = document.getElementById("status");
  const log = document.getElementById("log");
  const my = ++runningToken;

  log.innerHTML = "";
  scenarioEngine.activeCases.clear();
  scenarioEngine.caseIdCounter = 1;
  status.textContent = "ACTIVE";

  let n = 0;

  const caseInterval = setInterval(() => {
    if (my !== runningToken) { clearInterval(caseInterval); return; }
    updateCaseStatus();
  }, 1000);
  
  updateCaseStatus();

  while (my === runningToken) {
    const eventsToProcess = [];
    
    const busyUnits = new Set();
    for (const caseObj of scenarioEngine.activeCases.values()) {
        busyUnits.add(caseObj.unit);
        caseObj.backupUnits.forEach(u => busyUnits.add(u));
    }

    const activeCount = scenarioEngine.getVisibleCases().length;

    const caseIds = Array.from(scenarioEngine.activeCases.keys());
    for (const caseId of caseIds) {
      const event = scenarioEngine.progressCase(caseId, n, busyUnits);
      if (event) {
        eventsToProcess.push(event);
      }
    }

    if (activeCount < 5) {
      const newEvent = scenarioEngine.generateNewCase(n, busyUnits);
      if (newEvent) {
        eventsToProcess.push(newEvent);
        
        const newCaseId = newEvent.caseId;
        const newCase = scenarioEngine.activeCases.get(newCaseId);
        if (newCase) {
          busyUnits.add(newCase.unit);
        }

        const responseEvent = scenarioEngine.progressCase(newCaseId, n + 0.1, busyUnits);
        if (responseEvent) {
          eventsToProcess.push(responseEvent);
        }
      }
    }
    
    if (eventsToProcess.length > 0) {
      for (const event of eventsToProcess) {
        if (my !== runningToken) { clearInterval(caseInterval); return; }

        const caseObj = scenarioEngine.activeCases.get(event.caseId);
        if (caseObj && event.phase === 'dispatch' && !caseObj.isVisible) {
          caseObj.isVisible = true;
        }

        const row = document.createElement("div");
        row.className = "radio-message";

        const meta = document.createElement("div");
        meta.className = "radio-message-meta";

        const ts = document.createElement("div");
        ts.className = "msg-time";
        const now = new Date();
        ts.textContent = now.toLocaleTimeString("ja-JP", { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });

        const ch = document.createElement("div");
        ch.className = `msg-level lv${event.level}`;
        ch.textContent = `LV${event.level}`;

        const caseTag = document.createElement("div");
        caseTag.className = "msg-case";
        caseTag.textContent = event.caseId;

        meta.append(ts, ch, caseTag);

        const msg = document.createElement("div");
        msg.className = "msg-content";

        row.append(meta, msg);
        log.appendChild(row);
        
        if (!userScrolling) {
          setTimeout(() => { log.scrollTop = log.scrollHeight; }, 50);
        }

        if (TTS_ENABLED) {
          await Promise.all([
            typeOut(FIXED_SEED, BASE_CPS, event, msg),
            speakMessage(event.message)
          ]);
        } else {
          await typeOut(FIXED_SEED, BASE_CPS, event, msg);
        }
        await sleep(200);
      }
    }

    if (my !== runningToken) { clearInterval(caseInterval); break; }

    const waitTime = eventsToProcess.length > 0 ? 1000 : 800;
    await sleep(waitTime);
    n++;
  }
}

// ==========================================
// イベントリスナー
// ==========================================

function initializeSystem(csvText) {
    scenarioLoader = new ScenarioLoader();
    scenarioLoader.parseCSV(csvText);

    const unitTypes = {
        investigation: scenarioLoader.paramLists.units_investigation || [],
        traffic: scenarioLoader.paramLists.units_traffic || [],
        patrol: scenarioLoader.paramLists.units_patrol || [],
        backup: scenarioLoader.paramLists.units_backup || []
    };

    scenarioEngine = new ScenarioEngine(scenarioLoader, FIXED_SEED, unitTypes);
    
    document.getElementById("syncBtn").disabled = false;
    document.getElementById("caseList").innerHTML = '<div class="no-cases">✅ シナリオ読込完了。システムを起動してください</div>';
}

window.addEventListener('DOMContentLoaded', async () => {
  const locationInput = document.getElementById("locationInput");
  const systemTitle = document.getElementById("systemTitle");
  
  locationInput.addEventListener('input', (e) => {
    const newName = e.target.value.trim();
    locationName = newName || "本部";
    systemTitle.textContent = `${locationName}通信指令観測システム（CSV駆動版）`;
  });
  
  systemTitle.textContent = `${locationInput.value.trim()}通信指令観測システム（CSV駆動版）`;

  try {
    const response = await fetch('scenario.csv');
    if (response.ok) {
      const csvText = await response.text();
      initializeSystem(csvText);
    } else {
      document.getElementById("caseList").innerHTML = '<div class="no-cases">❌ scenario.csvの読込に失敗しました。</div>';
    }
  } catch (fetchError) {
    document.getElementById("caseList").innerHTML = '<div class="no-cases">❌ scenario.csvの読込に失敗しました。</div>';
  }

  // ▼▼▼ 操作パネルのトグル機能を追加 ▼▼▼
  document.getElementById("toggleControls").addEventListener("click", () => {
    const controlPanel = document.getElementById("controlPanel");
    controlPanel.classList.toggle("hidden");
  });
});

document.getElementById("syncBtn").addEventListener("click", () => {
  if (TTS_ENABLED) {
    startTimeSignal();
  }
  runSystem();
});

document.getElementById("ttsToggle").addEventListener("click", () => {
  TTS_ENABLED = !TTS_ENABLED;
  const btn = document.getElementById("ttsToggle");
  btn.textContent = `音声: ${TTS_ENABLED ? "ON" : "OFF"}`;
  btn.className = TTS_ENABLED ? "btn active" : "btn";
  
  if (TTS_ENABLED) {
    startTimeSignal();
  } else {
    stopTimeSignal();
  }
});

</script>
</body>
</html>