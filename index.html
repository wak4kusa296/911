<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>通信指令シミュレータ</title>
  <meta name="theme-color" content="#1a1a1a">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="指令システム">
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icon-192.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Barlow+Condensed:wght@600&family=Kosugi&family=M+PLUS+1p:wght@300;500;700&display=swap" rel="stylesheet">
  <style>
    @font-face {
      font-family: 'DSEG7';
      src: url('DSEG7ClassicMini-Bold.woff') format('woff');
    }

    :root {
      --bg-primary: #1a1a1a;
      --bg-secondary: #242424;
      --bg-tertiary: #2e2e2e;
      --border: #3a3a3a;
      --text-primary: #e0e0e0;
      --text-secondary: #a0a0a0;
      --text-muted: #707070;
      --accent-blue: #e0e0e0;
      --accent-cyan: #e0e0e0;
      --lv1: #4caf50;
      --lv2: #ff9800;
      --lv3: #f44336;
      --lv4: #9c27b0;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      overflow: hidden;
    }

    * {
      box-sizing: border-box
    }

    body {
      background: var(--bg-primary);
      color: var(--text-primary);
      font: 14px/1.6 'M PLUS 1p', sans-serif;
      display: grid;
      font-weight: 500;
      grid-template-rows: auto auto 1fr;
    }

    .system-header {
      background: var(--bg-secondary);
      border-bottom: 2px solid var(--border);
      padding: 16px 24px;
    }

    .header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px; /* ▼▼▼【変更】gapを少し狭く調整 ▼▼▼ */
      flex-wrap: wrap;
    }

    .system-title {
      font-size: 18px;
      font-weight: 500;
      color: var(--accent-cyan);
      letter-spacing: 1px;
      text-transform: uppercase;
      margin-right: auto; /* ▼▼▼【追加】タイトルを左寄せに保つ ▼▼▼ */
    }

    .system-clock {
      font-weight: 500;
      color: var(--accent-cyan);
      font-family: 'DSEG7', monospace;
      letter-spacing: 0.5px;
      width: 100%;
      font-size: 5cqw;
      text-align: center;
      padding: 36px;
    }

    .system-status {
      display: none;
    }

    .control-panel {
      width: 100%;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      padding: 12px 24px;
      transition: all 0.3s ease-in-out;
      overflow: hidden; /* ▼▼▼【追加】高さアニメーションのため ▼▼▼ */
    }

    /* ▼▼▼【変更】クラス名を is-open に変更し、非表示状態をデフォルトに ▼▼▼ */
    .control-panel:not(.is-open) {
      height: 0;
      padding-top: 0;
      padding-bottom: 0;
      border: none;
    }

    .control-row {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      width: 100%;
    }

    .btn {
      padding: 8px 20px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font: 12px/1.4 'Kosugi', 'M PLUS 1p', sans-serif;
      font-weight: 300;
      cursor: pointer;
      transition: all 0.2s;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      white-space: nowrap; /* ▼▼▼【追加】ボタンテキストの改行を防ぐ ▼▼▼ */
    }

    .btn:hover {
      background: var(--bg-primary);
      border-color: var(--accent-blue);
      color: var(--accent-blue);
    }

    .btn.primary {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: #000;
      font-weight: 500;
    }

    .btn.active {
      background: var(--accent-cyan);
      border-color: var(--accent-cyan);
      color: #000;
      font-weight: 500;
    }

    #closeControlsBtn {
      display: none;
    }

    .commander-input {
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font: 12px/1.4 'Kosugi', 'M PLUS 1p', sans-serif;
      min-width: 160px;
      height: 34px;
      flex-grow: 5;
    }

    .commander-input:focus {
      outline: none;
      border-color: var(--accent-blue);
    }

    .setting-lavel{
      width: 100%;
    }

    select {
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font: 12px/1.4 'Kosugi', 'M PLUS 1p', sans-serif;
      cursor: pointer;
      min-width: 200px;
      width: 100%;
    }

    .rate-slider.disabled,
    select.disabled {
      opacity: 0.4;
      pointer-events: none;
      cursor: not-allowed;
    }

    .main-content {
      display: grid;
      grid-template-columns: 400px 1fr;
      gap: 0;
      overflow: hidden;
      height: 100%;
    }

    .case-panel {
      background: var(--bg-secondary);
      border-right: 2px solid var(--border);
      display: flex;
      flex-direction: column;
      min-height: 0;
      height: 100%;
    }

    .panel-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      background: var(--bg-tertiary);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel-title {
      font-size: 13px;
      font-weight: 500;
      color: var(--accent-cyan);
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    .rate-slider {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      flex-grow: 1;
      flex-wrap: wrap;
    }

    .rate-slider label {
      font-size: 11px;
      color: var(--text-muted);
      letter-spacing: 0.5px;
    }

    .rate-slider input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100px;
      height: 4px;
      background: var(--border);
      outline: none;
      border-radius: 2px;
      flex-grow: 1;
    }

    .rate-slider input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: var(--accent-blue);
      border-radius: 50%;
      cursor: pointer;
    }

    .rate-slider .value {
      font-weight: 500;
      color: var(--accent-blue);
      min-width: 35px;
      text-align: right;
    }
    .case-list { flex: 1; overflow-y: auto; overflow-x: hidden; padding: 20px; }
    .case-card { border-bottom: 1px solid var(--border); transition: background 0.2s; padding-bottom: 10px; margin-bottom: 20px; }
    .case-header { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
    .level-badge { padding: 4px 10px; border-radius: 3px; font-size: 11px; font-weight: 500; letter-spacing: 0.5px; }
    .level-badge.lv1 { background: var(--lv1); color: #000; }
    .level-badge.lv2 { background: var(--lv2); color: #000; }
    .level-badge.lv3 { background: var(--lv3); color: #fff; }
    .level-badge.lv4 { background: var(--lv4); color: #fff; }
    .case-id { font-size: 13px; font-weight: 500; color: var(--accent-blue); }
    .case-type { font-size: 12px; color: var(--text-primary); margin-left: auto; }
    .case-body { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px; color: var(--text-secondary); }
    .case-info-row { display: flex; gap: 6px; }
    .info-label { color: var(--text-muted); }
    .info-value { color: var(--text-secondary); font-weight: 300; }
    .case-footer { margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; font-size: 11px; }
    .case-units { color: var(--accent-cyan); font-weight: 300; }
    .case-time { color: var(--text-muted); font-family: 'DSEG7', sans-serif; }
    .msg-time { color: var(--text-muted); font-family: 'DSEG7', sans-serif; }
    .radio-panel { background: var(--bg-primary); display: flex; flex-direction: column; min-height: 0; }
    .radio-log { flex: 1; overflow-y: auto; overflow-x: hidden; padding: 12px; padding-bottom: 40px; }
    .radio-message { display: flex; flex-direction: column; gap: 6px; padding: 12px 16px; margin-bottom: 8px; background: var(--bg-secondary); border-left: 3px solid transparent; border-radius: 4px; transition: all 0.2s; opacity: 0; transform: translateY(10px); animation: slideIn 0.3s ease-out forwards; }
    .radio-message.alert { background: repeating-linear-gradient( -45deg, rgba(33, 33, 33, 0.6), rgba(33, 33, 33, 0.6) 12px, var(--bg-secondary) 12px, var(--bg-secondary) 24px ); border-left-color: #ff3b3b; border-left-width: 4px; }
    .radio-message.alert .msg-content { text-shadow: 1px 1px 3px rgba(0,0,0,0.7); }
    @keyframes slideIn { to { opacity: 1; transform: translateY(0); } }
    .radio-message-meta { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    .msg-level { padding: 4px 8px; border-radius: 3px; font-size: 11px; font-weight: 500; text-align: center; letter-spacing: 0.5px; color: var(--text-muted); }
    .msg-case { font-size: 11px; font-weight: 500; color: var(--text-muted); }
    .msg-content { font: 13px/1.7 'Kosugi', 'M PLUS 1p', sans-serif; font-weight: 500; color: var(--text-primary); word-break: break-word; padding-top: 4px; }
    .no-cases { padding: 40px 20px; text-align: center; color: var(--text-muted); font-size: 12px; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: var(--bg-primary); }
    ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

    @media (max-width: 768px) {
      .main-content {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
      }

      .case-panel {
        border-right: none;
        border-bottom: 2px solid var(--border);
        max-height: 25dvh;
      }
      .system-title {
        width: 100%;
        font-size: 6cqw;
        text-align: center;
      }

      /* ▼▼▼【ここからモバイル用のオーバーレイスタイル】▼▼▼ */
      
      /* ▼▼▼ メディアクエリ内に追加 ▼▼▼ */
      #closeControlsBtn {
        display: block;
        width: 100%;
        margin-top: 24px;
        border-color: var(--text-muted);
      }
      
      .rate-slider .value {
        width: 100%;
     }

      .control-panel {
        /* オーバーレイの基本設定 */
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(26, 26, 26, 0.95);
        backdrop-filter: blur(4px);
        /* 警報オーバーレイより手前に表示 */
        z-index: 10000; 
        
        /* ▼▼▼【変更】スクロール可能にしつつ中央揃えを維持 ▼▼▼ */
        display: flex;
        align-items: flex-start; /* centerからflex-startに変更 */
        justify-content: center;
        padding: 24px;
        overflow-y: auto;
        overflow-x: hidden;
        /* ▲▲▲【変更】ここまで ▲▲▲ */

        /* 表示/非表示のアニメーション設定 */
        opacity: 0;
        transform: scale(1.05);
        pointer-events: none;
        transition: opacity 0.2s ease-out, transform 0.2s ease-out;
      }
            
      /* is-openクラスが付いた時に表示する */
      .control-panel.is-open {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
      }

      .control-row {
        flex-direction: column;
        align-items: stretch;
        max-width: 400px; /* オーバーレイ内での最大幅 */
      }

      .commander-input,
      select,
      .rate-slider {
        min-width: 0;
        width: 100%;
      }
      
      .btn {
        flex-grow: 1;
      }
      /* ▲▲▲【ここまで】▲▲▲ */
      .system-clock {
        font-weight: 500;
        color: var(--accent-cyan);
        font-family: 'DSEG7', monospace;
        letter-spacing: 0.5px;
        width: 100%;
        font-size: 10cqw;
        text-align: center;
        padding: 0px;
      }

    }

    /* --- Emergency Overlay Styles (変更なし) --- */
    #emergency-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 9999; text-align: center; opacity: 0; pointer-events: none; transition: opacity 0.1s ease-in-out; backdrop-filter: blur(5px); }
    #emergency-overlay.active { opacity: 1; pointer-events: auto; }
    .emergency-text-wrapper { max-width: 95%; animation: sawtooth-fade 0.5s linear infinite; }
    .emergency-title { background-color: #ff3b3b; color: #1a1a1a; font-family: 'Barlow Condensed', sans-serif; font-weight: 600; font-size: clamp(16px, 3.5vw, 2rem); letter-spacing: 0.05em; text-transform: uppercase; padding: 0.6rem 1.5rem; margin-bottom: 1rem; white-space: nowrap; }
    .emergency-subtitle { color: #ff3b3b; text-shadow: 0 0 8px rgba(255, 59, 59, 0.8); font-size: clamp(14px, 2.5vw, 1.2rem); font-weight: 500; letter-spacing: 0.2em; white-space: nowrap; }
    .stripe-band { position: fixed; left: 0; width: 100%; height: 40px; background-image: repeating-linear-gradient( -45deg, #ff3b3b, #ff3b3b 15px, transparent 15px, transparent 30px ); background-size: 42.4264px 42.4264px; box-shadow: 0 0 15px rgba(0, 0, 0, 0.5); animation: scroll-stripe 0.7s linear infinite; }
    .stripe-band.top { top: 0; }
    .stripe-band.bottom { bottom: 0; }
    @keyframes scroll-stripe { from { background-position-x: 0; } to { background-position-x: -42.4264px; } }
  </style>
</head>

<body>
  <div id="emergency-overlay">
    <div class="stripe-band top"></div>
    <div class="emergency-text-wrapper">
      <div class="emergency-title">Automatic Calling System</div>
      <div class="emergency-subtitle">注意喚起音</div>
    </div>
    <div class="stripe-band bottom"></div>
  </div>

  <div class="system-header">
    <div class="header-row">
      <div class="system-title" id="systemTitle">通信指令シミュレータ</div>
      <div class="system-status" id="status">STANDBY</div>
      
      <button id="toggleControls" class="btn">設定</button>
      <button id="ttsToggle" class="btn">音声: OFF</button>
      <button id="syncBtn" class="btn primary">再読み込み</button>

      
      <div class="system-clock" id="jst">--:--:--.-- JST</div>
    </div>
  </div>

  <div class="control-panel" id="controlPanel">
    <div class="control-row">
      <label class="setting-lavel">ドラマチックモード（重大事案のみ発生させるモード）</label>
      <button id="specialAlertModeToggle" class="btn">ドラマチックモード: OFF</button>
      <label class="setting-lavel">本部の名称</label>
      <input type="text" id="commanderInput" class="commander-input" value="本部">
      <label class="setting-lavel">音声設定（音声ONの時のみ編集可能）</label>
      <button id="ttsToggle2" class="btn">音声: OFF</button>
      <select id="voiceSel">
        <option value="">音声自動選択</option>
      </select>
      <div class="rate-slider">
        <label>速度:</label>
        <input type="range" id="rateSlider" min="0.5" max="3.0" step="0.1" value="1.5">
        <span class="value" id="rateValue">1.5</span>
      </div>
      <div class="rate-slider">
        <label>全体音量:</label>
        <input type="range" id="masterVolumeSlider" min="0" max="2" step="0.05" value="1.0">
        <span class="value" id="masterVolumeValue">1.00</span>
      </div>
      <div class="rate-slider">
        <label>ボイス音量:</label>
        <input type="range" id="ttsVolumeSlider" min="0" max="1" step="0.05" value="1.0">
        <span class="value" id="ttsVolumeValue">1.00</span>
      </div>
      <div class="rate-slider">
        <label>効果音音量:</label>
        <input type="range" id="sfxVolumeSlider" min="0" max="1" step="0.05" value="1.0">
        <span class="value" id="sfxVolumeValue">1.00</span>
      </div>
      <div class="rate-slider">
        <label>時報音量:</label>
        <input type="range" id="timeSigVolumeSlider" min="0" max="1" step="0.05" value="0.5">
        <span class="value" id="timeSigVolumeValue">0.50</span>
      </div>
      <div class="rate-slider">
        <label>無線ノイズ音量:</label>
        <input type="range" id="noiseVolumeSlider" min="0" max="1" step="0.05" value="0.5">
        <span class="value" id="noiseVolumeValue">0.50</span>
      </div>
      
      <button id="closeControlsBtn" class="btn">閉じる</button>
    </div>
  </div>

  <div class="main-content">
    <div class="case-panel">
      <div class="panel-header">
        <div class="panel-title">進行中の事案</div>
      </div>
      <div class="case-list" id="caseList">
        <div class="no-cases">CSVファイルを読み込んでください</div>
      </div>
    </div>

    <div class="radio-panel">
      <div class="radio-log" id="log"></div>
    </div>
  </div>
<script>
// グローバル変数
let ttsVolume = 1.0; // TTS音量だけは別で保持
let isSpecialAlertMode = false; // ▼▼▼【追加】ドラマチックモードモードの状態管理フラグ

const BASE_CPS = 12;
let commanderName = "本部";
let whiteNoiseNode = null;
let TTS_ENABLED = false;
let chosenVoice = null;
let ttsRate = 1.5;
let audioCtx = null;
let masterGain = null;
let timeSigGain = null; // ★ NEW: 時報専用
let sfxGain = null;
let noiseGain = null;
let scenarioLoader = null;
let scenarioEngine = null;
let runningToken = 0;
let tickTimer = null;
let userScrolling = false;
let scrollTimeout = null;

let ttsAbort = false;
let ttsTestTimer = null;



// ==========================================
// 設定の保存・復元、および関連処理
// ==========================================

const SETTINGS_KEY = 'simulatorSettings';

function saveSettings() {
  const settings = {
    commanderName: document.getElementById('commanderInput').value.trim() || "本部",
    ttsRate:       parseFloat(document.getElementById('rateSlider').value),

    masterVolume:  parseFloat(document.getElementById('masterVolumeSlider').value),
    ttsVolume:     parseFloat(document.getElementById('ttsVolumeSlider').value),
    sfxVolume:     parseFloat(document.getElementById('sfxVolumeSlider').value),

    // ★ 追加: 時報音量
    timeSigVolume: parseFloat(document.getElementById('timeSigVolumeSlider').value),

    noiseVolume:   parseFloat(document.getElementById('noiseVolumeSlider').value),

    voiceIndex:    parseInt(document.getElementById('voiceSel').value) || 0,
    ttsEnabled:    TTS_ENABLED,
    isSpecialAlertMode: isSpecialAlertMode
  };

  localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
}

let __didLoadSettings = false; // 二重初期化で設定が巻き戻らないようにする

async function loadSettings() {
  if (__didLoadSettings) {
    return;
  }
  __didLoadSettings = true;

  const savedSettings = localStorage.getItem(SETTINGS_KEY);

  if (!savedSettings) {
    // 初回デフォルト
    const commanderInput = document.getElementById("commanderInput");
    document.getElementById("systemTitle").textContent =
      `${commanderInput.value.trim()}通信指令シミュレータ`;

    // 音声OFF扱いなのでスライダー無効化
    const sliders = document.querySelectorAll('.rate-slider, #voiceSel');
    sliders.forEach(el => el.classList.add('disabled'));
    return;
  }

  try {
    const settings = JSON.parse(savedSettings);

    // =========================
    // 1. 基本設定復元（本部名）
    // =========================
    const commanderInput = document.getElementById('commanderInput');
    commanderName = settings.commanderName || "本部";
    commanderInput.value = commanderName;
    document.getElementById("systemTitle").textContent =
      `${commanderName}通信指令シミュレータ`;

    // =========================
    // 2. スライダー値の復元
    // =========================
    const slidersMap = {
      rateSlider:           { valueId: 'rateValue',           key: 'ttsRate',        fixed: 1, globalVar: 'ttsRate' },
      masterVolumeSlider:   { valueId: 'masterVolumeValue',   key: 'masterVolume',   fixed: 2 },
      ttsVolumeSlider:      { valueId: 'ttsVolumeValue',      key: 'ttsVolume',      fixed: 2, globalVar: 'ttsVolume' },
      sfxVolumeSlider:      { valueId: 'sfxVolumeValue',      key: 'sfxVolume',      fixed: 2 },
      timeSigVolumeSlider:  { valueId: 'timeSigVolumeValue',  key: 'timeSigVolume',  fixed: 2 },
      noiseVolumeSlider:    { valueId: 'noiseVolumeValue',    key: 'noiseVolume',    fixed: 2 },
    };

    for (const [sliderId, data] of Object.entries(slidersMap)) {
      if (settings[data.key] !== undefined) {
        const sliderEl = document.getElementById(sliderId);
        const value = parseFloat(settings[data.key]);

        if (sliderEl) {
          sliderEl.value = value;
        }

        const valueEl = document.getElementById(data.valueId);
        if (valueEl) {
          valueEl.textContent = value.toFixed(data.fixed);
        }

        if (data.globalVar === 'ttsRate') {
          ttsRate = value;
        } else if (data.globalVar === 'ttsVolume') {
          ttsVolume = value;
        }
      }
    }

    // =========================
    // 3. すでにAudioノードがある場合だけゲイン反映
    //    （AudioContextはここでは作らない）
    // =========================
    if (typeof masterGain !== "undefined" &&
        masterGain &&
        settings.masterVolume !== undefined) {
      masterGain.gain.setValueAtTime(
        parseFloat(settings.masterVolume),
        audioCtx?.currentTime || 0
      );
    }

    if (typeof timeSigGain !== "undefined" &&
        timeSigGain &&
        settings.timeSigVolume !== undefined) {
      timeSigGain.gain.setValueAtTime(
        parseFloat(settings.timeSigVolume),
        audioCtx?.currentTime || 0
      );
    }

    if (typeof sfxGain !== "undefined" &&
        sfxGain &&
        settings.sfxVolume !== undefined) {
      sfxGain.gain.setValueAtTime(
        parseFloat(settings.sfxVolume),
        audioCtx?.currentTime || 0
      );
    }

    if (typeof noiseGain !== "undefined" &&
        noiseGain &&
        settings.noiseVolume !== undefined) {
      noiseGain.gain.setValueAtTime(
        parseFloat(settings.noiseVolume),
        audioCtx?.currentTime || 0
      );
    }

    // =========================
    // 4. 特別警戒モード復元
    // =========================
    if (typeof settings.isSpecialAlertMode === 'boolean') {
      isSpecialAlertMode = settings.isSpecialAlertMode;
      const specialAlertModeBtn = document.getElementById("specialAlertModeToggle");
      if (specialAlertModeBtn) {
        specialAlertModeBtn.textContent =
          `特別警戒: ${isSpecialAlertMode ? "ON" : "OFF"}`;
        specialAlertModeBtn.classList.toggle("active", isSpecialAlertMode);
      }
    }

    // =========================
    // 5. TTS音声 (iOS / Safari 対応・状態保持対応)
    // =========================
    const voiceSelEl = document.getElementById("voiceSel");

    if (voiceSelEl && 'speechSynthesis' in window) {

      // (A) まずは安定して voices を取るヘルパー
      async function getStableVoices() {
        // 1. いまのリスト
        let voices = speechSynthesis.getVoices();
        if (voices.length > 0) return voices;

        // 2. iOS対策: 無音Utteranceでエンジン起こす
        await new Promise(r => {
          const u = new SpeechSynthesisUtterance(' ');
          u.volume = 0;
          u.rate = 1;
          u.onend = r;
          try {
            speechSynthesis.speak(u);
          } catch (_) {
            r();
          }
        });

        // 3. 再取得
        voices = speechSynthesis.getVoices();
        if (voices.length > 0) return voices;

        // 4. 最後に voiceschanged or タイムアウト待ち
        return await new Promise(resolve => {
          let done = false;
          function finish(vs) {
            if (done) return;
            done = true;
            resolve(vs);
          }

          const vsNow = speechSynthesis.getVoices();
          if (vsNow.length > 0) {
            finish(vsNow);
            return;
          }

          window.addEventListener(
            'voiceschanged',
            () => finish(speechSynthesis.getVoices()),
            { once: true }
          );

          setTimeout(() => {
            finish(speechSynthesis.getVoices());
          }, 500);
        });
      }

      const voices = await getStableVoices();

      if (!voices || voices.length === 0) {
        // Safariがまだvoiceを返してない → 何もしない
        console.warn('[TTS] No voices available yet (Safari delayed).');
        chosenVoice = null;
      } else {
        // 日本語優先
        const jaVoices = voices.filter(v => /^ja/i.test(v.lang));
        const listForSelect = jaVoices.length > 0 ? jaVoices : voices;

        // (B) セレクトを構築する。optionのvalueに「元のvoices配列のインデックス」を埋める
        voiceSelEl.innerHTML = listForSelect
          .map(v => {
            const realIndex = voices.indexOf(v); // ←これがズレ防止の肝
            return `<option value="${realIndex}">${v.name} (${v.lang})</option>`;
          })
          .join('');

        // (C) 設定側のvoiceIndexを尊重して chosenVoice を決める
        const idxFromSettings = parseInt(settings.voiceIndex);
        let candidate = null;
        if (!isNaN(idxFromSettings) && voices[idxFromSettings]) {
          candidate = voices[idxFromSettings];
        }

        chosenVoice =
          candidate ||
          jaVoices[0] ||
          voices[0] ||
          null;

        // UI上の選択状態を chosenVoice に合わせる
        if (chosenVoice) {
          const chosenRealIndex = voices.indexOf(chosenVoice);
          if (chosenRealIndex >= 0) {
            voiceSelEl.value = String(chosenRealIndex);
          }
        }

        console.log('[TTS] chosenVoice:', chosenVoice);
      }

      // (D) ユーザーがドロップダウンを変えたら必ず chosenVoice を更新＆保存
      voiceSelEl.addEventListener('change', () => {
        const allVoices = speechSynthesis.getVoices();
        const newIdx = parseInt(voiceSelEl.value);
        if (!isNaN(newIdx) && allVoices[newIdx]) {
          chosenVoice = allVoices[newIdx];
        }

        saveSettings();
      });
    }

  } catch (e) {
    console.error("設定の読み込みに失敗しました:", e);
    localStorage.removeItem(SETTINGS_KEY);
  }
}


// --- PATCH START (iOS TTS warmup) ---
let ttsReady = false;

function isiOS() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) ||
         (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
}

// iOS / iPadOS / Safari 対策：
// - 初回タップの中で無音Utteranceを一度だけしゃべらせて
//   speechSynthesisエンジンを起こす
// - その後で loadSettings() 相当の voice 選択ロジックをもう一度走らせて
//   chosenVoice をちゃんと埋める
async function initTTS() {
  if (ttsReady || !('speechSynthesis' in window)) return;

  await new Promise((resolve) => {
    const u = new SpeechSynthesisUtterance(' ');
    u.volume = 0;
    u.rate = 1;
    u.onend = () => {
      ttsReady = true;

      // Safariはここでやっと voices が返り始めることがあるので、
      // いまの loadSettings() の voice 部分だけもう一度実行して chosenVoice を固める
      (async () => {
        const voiceSelect = document.getElementById('voiceSel');
        if (!voiceSelect) {
          resolve();
          return;
        }

        // これは loadSettings() と同じロジックを再利用する
        async function getStableVoices() {
          let voices = speechSynthesis.getVoices();
          if (voices.length > 0) return voices;

          // fallback: もう一回だけ声を聞かせて刺激する
          await new Promise(r2 => {
            const u2 = new SpeechSynthesisUtterance(' ');
            u2.volume = 0;
            u2.rate = 1;
            u2.onend = r2;
            try { speechSynthesis.speak(u2); } catch { r2(); }
          });

          voices = speechSynthesis.getVoices();
          if (voices.length > 0) return voices;

          return voices; // ここではこれ以上は待たない（タップ中なのでブロックしない）
        }

        const voices = await getStableVoices();
        if (voices && voices.length > 0) {
          const jaVoices = voices.filter(v => /^ja/i.test(v.lang));
          const renderList = jaVoices.length > 0 ? jaVoices : voices;

          voiceSelect.innerHTML = renderList
            .map((v, i) => `<option value="${i}">${v.name} (${v.lang})</option>`)
            .join('');

          chosenVoice =
            jaVoices[0] ||
            voices[0] ||
            null;

          voiceSelect.value = "0";
          console.log('[TTS:initTTS] chosenVoice:', chosenVoice);
        }

        resolve();
      })();
    };

    try {
      speechSynthesis.speak(u);
    } catch {
      // speak() が例外でも resolve だけは呼ぶ
      resolve();
    }
  });
}
// --- PATCH END (iOS TTS warmup) ---

function toggleTTS() {
  const wasEnabled = TTS_ENABLED;
  TTS_ENABLED = !TTS_ENABLED;

  // これがトグルOFFでの「もうしゃべらなくていい」フラグ
  if (!TTS_ENABLED) {
    ttsAbort = true;
  }

  const btn1 = document.getElementById("ttsToggle");
  const btn2 = document.getElementById("ttsToggle2");
  const text = `音声: ${TTS_ENABLED ? "ON" : "OFF"}`;
  const className = TTS_ENABLED ? "btn active" : "btn";

  if (btn1) {
    btn1.textContent = text;
    btn1.className = className;
  }
  if (btn2) {
    btn2.textContent = text;
    btn2.className = className;
  }

  // スライダー群の有効/無効
  const sliders = document.querySelectorAll('.rate-slider, #voiceSel');
  sliders.forEach(el => el.classList.toggle('disabled', !TTS_ENABLED));

  if (TTS_ENABLED) {
    // ONにしたとき
    ensureAudio();
    startTimeSignal();
  } else {
    // OFFにしたとき
    stopTimeSignal();
    if ('speechSynthesis' in window) {
      try { speechSynthesis.cancel(); } catch {}
    }
    // ノイズ・送受信音を止めるハンドラがあれば呼ぶ
    if (typeof stopWhiteNoise === 'function') {
      try { stopWhiteNoise(); } catch {}
    }
  }

  saveSettings();
}


/**
 * 音声ON/OFFボタン（2つ）のイベントリスナー
 */
// --- PATCH START (iOS-friendly button handlers) ---

document.getElementById("ttsToggle").addEventListener("click", async () => {
  await initTTS();        // iOSはユーザー操作の中でTTSエンジンを起こす
  toggleTTS();
});

document.getElementById("ttsToggle2").addEventListener("click", async () => {
  await initTTS();
  toggleTTS();
});

// syncBtn は「再読み込み」ボタン。
// ここでいきなり location.href を変える前に、TTSをちゃんとキャンセルしておく＋iOSエンジン起こし
document.getElementById("syncBtn").addEventListener("click", async () => {
  await initTTS();
  if ('speechSynthesis' in window) {
    try { speechSynthesis.cancel(); } catch {}
  }
  const url = new URL(location.href);
  url.searchParams.set('restart', 'true');
  location.href = url.toString();
});

// --- PATCH END (iOS-friendly button handlers) ---

// ==========================================
// シナリオCSVローダー
// ==========================================

class ScenarioLoader {
  constructor() {
    this.paramLists = {};
    this.scenarios = [];
    this.scenarioMap = new Map();
  }

  // ▼▼▼【ここから修正】「NAME」行を「確率」行に変更 ▼▼▼
  parseCSV(csvText) {
    const lines = csvText.split('\n').filter(line => {
      const trimmed = line.trim();
      return trimmed && !trimmed.startsWith('#');
    });

    let currentLevel = null;
    let currentScenario = null;
    const nodeStack = [];

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const cols = this.parseCSVLine(line); 
      const sectionOrProb = cols[0].trim();
      const depth = this.getIndentDepth(line); // ★ インデントを先に取得

      if (sectionOrProb === 'PARAM') {
        // PARAM, id, , , , , params
        const [, id, , , , , params] = cols;
        this.paramLists[id] = params ? params.split(';').map(s => s.trim()) : [];
      } 
      else if (sectionOrProb === 'LEVEL') {
        // LEVEL, id, ...
        const [, id] = cols;
        currentLevel = { level: id, scenarios: [] };
        this.scenarios.push(currentLevel);
        nodeStack.length = 0; 
      }
      else if (depth === 0 && !isNaN(parseFloat(sectionOrProb))) {
        // 事案定義行 (インデント0 かつ 1列目が数値)
        // 例: 0.5,ハイジャック事案,,,,,type=hijack;level=4
        
        const probability = parseFloat(sectionOrProb);
        const id = cols[1]; // ハイジャック事案
        const params = cols[6]; // 7列目
        const paramsObj = this.parseParams(params);

        // LEVEL行がCSVにない場合、paramsのlevel=Nから推測（フォールバック）
        if (!currentLevel) {
            const levelStr = `Lv${parseInt(paramsObj.level) || 1}`;
            currentLevel = this.scenarios.find(l => l.level === levelStr);
            if (!currentLevel) {
                currentLevel = { level: levelStr, scenarios: [] };
                this.scenarios.push(currentLevel);
            }
        }

        currentScenario = {
          name: id,
          type: paramsObj.type || 'unknown',
          level: parseInt(paramsObj.level) || 1,
          probability: probability, // ★ 1列目の確率を事案の発生確率として設定
          rootNodes: []
        };
        currentLevel.scenarios.push(currentScenario);
        this.scenarioMap.set(paramsObj.type, currentScenario);
        nodeStack.length = 0; // スタックリセット
      }
      else if (currentScenario && depth > 0 && !isNaN(parseFloat(sectionOrProb))) {
        // NODE行 (インデントあり かつ 1列目が数値)
        // 例:   1.0,派遣要請,{msg},"{params}"
        
        const probability = parseFloat(sectionOrProb);
        const phase = cols[1];
        const message = cols[2];
        const paramsStr = cols[3]; // 4カラム目
        const paramsObj = this.parseParams(paramsStr);
        
        const node = {
          id: phase.trim(),
          depth,
          condition: null, // ★ あとで推測
          probability: probability,
          phase: phase,
          message: message,
          params: paramsObj,
          children: []
        };

        // 親ノードを探す (自分より浅いインデントが見つかるまでスタックを遡る)
        while (nodeStack.length > 0 && nodeStack[nodeStack.length - 1].depth >= depth) {
          nodeStack.pop();
        }

        if (nodeStack.length === 0) {
          // 親がいない ＝ rootNode
          // (depth === 1 であることを期待するが、depth > 0 であればrootNodeとして扱う)
          node.condition = 'default'; // ★ 'new_case' は使われないので 'default' に
          currentScenario.rootNodes.push(node);
        } else {
          // 子ノード
          const parentNode = nodeStack[nodeStack.length - 1];
          parentNode.children.push(node);
          
          // Conditionの推測
          if (parentNode.params && parentNode.params['need-response'] === 'true') {
              node.condition = 'awaiting_response';
          } else {
              node.condition = 'default'; 
          }
        }
        nodeStack.push(node); // 自分をスタックに追加
      }
    }
  }
  // ▲▲▲【ここまで修正】▲▲▲
  
  parseCSVLine(line) {
    const regex = /(?:^|,)(\"(?:[^\"]+|\"\")*\"|[^,]*)/g;
    const result = [];
    let match;
    while (match = regex.exec(line)) {
      let value = match[1];
      if (value.startsWith('"') && value.endsWith('"')) {
        value = value.substring(1, value.length - 1).replace(/""/g, '"');
      }
      result.push(value.trim());
    }
    
    if (line.endsWith(',')) {
        result.push('');
    }

    while (result.length < 7) {
      result.push('');
    }

    return result;
  }

  getIndentDepth(line) {
    const match = line.match(/^(\s*)/);
    if (!match) return 0;

    // 1. タブ文字(\t)を、意図する「半角スペース2つ」に置換
    let indentString = match[1].replace(/\t/g, '  ');
    
    // 2. その他の特殊な空白文字(\u00A0など)を半角スペースに正規化
    indentString = indentString.replace(/\u00A0/g, ' '); 
    
    // ▼▼▼【最終修正】全角スペースを半角スペース2つに置換 ▼▼▼
    indentString = indentString.replace(/　/g, '  ');
    // ▲▲▲【最終修正】▲▲▲

    // 正規化された文字列の長さで、インデントレベルを計算
    // (スペース2つでインデント1とする)
    return Math.floor(indentString.length / 2);
  }

  parseParams(paramsStr) {
    if (!paramsStr) return {};
    const pairs = paramsStr.split(';').filter(p => p.trim());
    const result = {};
    for (const pair of pairs) {
      const [key, value] = pair.split('=').map(s => s.trim());
      // ▼▼▼【修正】キー重複時に上書きせず、';'で連結する ▼▼▼
      if (key && value) {
        if (result[key]) {
          result[key] = `${result[key]};${value}`;
        } else {
          result[key] = value;
        }
      }
      // ▲▲▲【修正】▲▲▲
    }
    return result;
  }
  
  async loadFromFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          this.parseCSV(e.target.result);
          resolve();
        } catch (error) {
          reject(error);
        }
      };
      reader.onerror = reject;
      reader.readAsText(file);
    });
  }
}

// ==========================================
// メッセージパーサー
// ==========================================
class MessageParser {
  constructor(paramLists) {
    this.paramLists = paramLists;
  }

  parse(template, context) {
    let result = template;
    let lastResult = '';

    while (result !== lastResult) {
        lastResult = result;

        result = result.replace(/\{([^}#]+\/[^}]+)\}/g, (match, items) => {
          const choices = items.split('/').map(s => s.trim());
          const index = Math.floor(Math.random() * choices.length);
          return choices[index];
        });

        result = result.replace(/\{#(\w+):(\d+)-(\d+)\}/g, (match, name, min, max) => {
          const minVal = parseInt(min);
          const maxVal = parseInt(max);
          return Math.floor(Math.random() * (maxVal - minVal + 1)) + minVal;
        });

        result = result.replace(/\{#(\w+)\}/g, (match, name) => {
          if (name === 'num') {
            return Math.floor(Math.random() * 3) + 1;
          }
          if (name === 'eta') {
            return Math.floor(Math.random() * 9) + 2;
          }
          if (this.paramLists[name]) {
            const list = this.paramLists[name];
            const index = Math.floor(Math.random() * list.length);
            return list[index];
          }
          return match;
        });

        result = result.replace(/\{(\w+)\}/g, (match, key) => {
          const value = context[key];
          return (value !== undefined && value !== null) ? value : '';
        });
    }

    result = result.replace(/\{([^{}]+)\}/g, (match, content) => content);
    result = result.replace(/、\s*、/g, '、').replace(/、$/g, '');

    return result;
  }
}


// ==========================================
// シナリオエンジン
// ==========================================
class ScenarioEngine {
  constructor(loader, unitTypes) {
    this.loader = loader;
    this.parser = new MessageParser(loader.paramLists);
    this.unitTypes = unitTypes;
    this.activeCases = new Map();
    this.caseIdCounter = 1;
    this.nodeIdCounter = 1;
    // backup-all機能用のプロパティ
    this.isBackupAllActive = false;
    this.backupAllCaseId = null;
  }

  evaluateCondition(condition, caseState) {
    if (!condition) return false;
    switch (condition) {
      case 'new_case': return caseState.isNew;
      case 'awaiting_response': return caseState.awaitingResponse;
      case 'default': return true;
      case 'has_units': return caseState.hasAvailableBackupUnits;
      default:
        if (condition.startsWith('rand<')) {
          const threshold = parseFloat(condition.substring(5));
          return Math.random() < threshold;
        }
        return false;
    }
  }

  selectNextNode(currentNode, caseState) {
    const candidates = currentNode.children.filter(child => {
      const conditionMet = this.evaluateCondition(child.condition, caseState);
      const probabilityMet = Math.random() < child.probability;
      return conditionMet && probabilityMet;
    });
    if (candidates.length === 0) {
      return currentNode.children.find(child => child.condition === 'default') || null;
    }
    return candidates[0];
  }


// ▼▼▼【ここから修正】rootNodeが複数ある場合の確率分岐に対応 ▼▼▼
generateNewCase(busyUnits) {

  const randomDelay = Math.random() * 4000 + 500;
  // ▼▼▼【ここから変更】ドラマチックモードモードのロジック ▼▼▼
  let candidateScenarios;
  if (isSpecialAlertMode) {
  // 全シナリオを一旦フラットにしてから、
  // そのシナリオ個別の .level が 3以上のものだけ残す
  candidateScenarios = this.loader.scenarios
    .flatMap(levelGroup => levelGroup.scenarios)
    .filter(scenario => scenario.level >= 3);
} else {
  // 通常時は全部
  candidateScenarios = this.loader.scenarios
    .flatMap(levelGroup => levelGroup.scenarios);
}
// 通常モードの場合はすべてのシナリオを候補にする

  
  const totalWeight = candidateScenarios.reduce((sum, s) => sum + s.probability, 0);
  if (totalWeight <= 0) return null;

  // シナリオを確率に基づいて選択
  let selectedScenario = null;
  const r = Math.random() * totalWeight;
  let cumulative = 0;
  for (const scenario of candidateScenarios) { // 候補リストを `candidateScenarios` に変更
      cumulative += scenario.probability;
      if (r <= cumulative) {
          selectedScenario = scenario;
          break;
      }
  }
  // ▲▲▲【ここまで変更】▲▲▲
  
  if (!selectedScenario) return null;

  // ▼▼▼【ここから変更】rootNodesから確率で選択 ▼▼▼
  if (!selectedScenario.rootNodes || selectedScenario.rootNodes.length === 0) {
      console.error(`シナリオ "${selectedScenario.name}" にルートノードがありません。`);
      return null;
  }

  let firstNode = null;
  if (selectedScenario.rootNodes.length === 1) {
      firstNode = selectedScenario.rootNodes[0];
  } else {
      // 複数のrootNodeがある場合、確率で分岐
      const totalRootWeight = selectedScenario.rootNodes.reduce((sum, node) => sum + node.probability, 0);
      const rNode = Math.random() * totalRootWeight;
      let cumulativeNode = 0;
      for (const node of selectedScenario.rootNodes) {
          cumulativeNode += node.probability;
          if (rNode <= cumulativeNode) {
              firstNode = node;
              break;
          }
      }
      if (!firstNode) firstNode = selectedScenario.rootNodes[0]; // フォールバック
  }
  // ▲▲▲【変更ここまで】▲▲▲

  const isTriggeringBackupAll = firstNode.params && firstNode.params['backup-all'] === 'true';

  // ▼▼▼【ここから修正】backup-allが既に発令中の場合、新しいbackup-all事案を生成しない ▼▼▼
  if (this.isBackupAllActive && isTriggeringBackupAll) {
      console.log(`[System] generateNewCase: 既存のbackup-all事案 (${this.backupAllCaseId}) が実行中のため、新規backup-all事案 (${selectedScenario.name}) の生成を待機します。`);
      return null; // ★★★ 新規のbackup-all事案をブロック
  }
  // ▲▲▲【修正ここまで】▲▲▲

  const availableBackupUnits = (this.unitTypes.backup || []).filter(u => !busyUnits.has(u));
  
  let unit;
  let backupUnitsForCase = [];

  // --- backup-allと通常事案の分岐処理 ---
  if (isTriggeringBackupAll) {
      // --- backup-allのロジック ---
      // (この時点で this.isBackupAllActive は false であることが保証されている)
      console.log('--- DEBUG: generateNewCase (backup-all) ---');
      console.log('this.unitTypes.backup:', this.unitTypes.backup);
      console.log('availableBackupUnits.length:', availableBackupUnits.length);
      console.log('---------------------------------');

      if (availableBackupUnits.length === 0) {
          // ★ ユニット不足で発令できない場合も待機
          console.log(`[System] generateNewCase: backup-all事案 (${selectedScenario.name}) を生成しようとしましたが、利用可能なユニットが0のため待機します。`);
          return null;
      }
      
      const primaryUnitIndex = Math.floor(Math.random() * availableBackupUnits.length);
      unit = availableBackupUnits[primaryUnitIndex];
      backupUnitsForCase = availableBackupUnits.filter((_, index) => index !== primaryUnitIndex);

      // グローバルなbackup-all状態を設定
      this.isBackupAllActive = true;
      this.backupAllCaseId = `C${String(this.caseIdCounter).padStart(4, '0')}`; // ★ IDは後で設定するcaseIdと合わせる

  } else {
      // --- 通常事案のロジック ---
      
      // ▼▼▼【追加】backup-all発令中は、backupユニットを必要とする新規事案をブロック ▼▼▼
      const scenarioType = selectedScenario.type;
      if (this.isBackupAllActive && scenarioType === 'backup') {
          console.log(`[System] generateNewCase: backup-all発令中のため、新規backup事案 (${selectedScenario.name}) の生成を待機します。`);
          return null;
      }
      // ▲▲▲【追加ここまで】▲▲▲
      
      let unitTypeKey;
      
      if (['investigation'].includes(scenarioType)) {
          unitTypeKey = 'investigation';
      } else if (['traffic'].includes(scenarioType)) {
          unitTypeKey = 'traffic';
      } else if (['patrol'].includes(scenarioType)) {
          unitTypeKey = 'patrol';
      } else {
          unitTypeKey = 'backup';
      }
      
      const unitPool = this.unitTypes[unitTypeKey] || [];
      const availableUnitsForCase = unitPool.filter(u => !busyUnits.has(u));
      
      if (unitTypeKey === 'backup') {
          const backupUnitsBusy = Array.from(busyUnits).some(u => 
              (this.unitTypes.backup || []).includes(u)
          );
          
          if (backupUnitsBusy) {
              return null;
          }
      }
      
      if (availableUnitsForCase.length === 0) {
          return null;
      }
      unit = availableUnitsForCase[Math.floor(Math.random() * availableUnitsForCase.length)];
  }

  // --- 全ての事案に共通のロジック ---
  const caseId = `C${String(this.caseIdCounter++).padStart(4, '0')}`;
  if (isTriggeringBackupAll) {
      this.backupAllCaseId = caseId; // ★ここでcaseIdを正式に割り当て
  }
  const zoneList = this.loader.paramLists.zones || [];
  const zone = zoneList[Math.floor(Math.random() * zoneList.length)];
  
  const caseObj = {
    id: caseId, scenario: selectedScenario, currentNode: firstNode,
    zone, unit, backupUnits: backupUnitsForCase, level: selectedScenario.level,
    startTime: Date.now(), awaitingResponse: true, phase: firstNode.phase,
    isVisible: false
  };

  if (firstNode.params && firstNode.params.add_units) {
      const newUnits = new Set(caseObj.backupUnits);
      // ▼▼▼【修正】';' と '・' の両方で分割してユニットを追加 ▼▼▼
      firstNode.params.add_units.split(';').forEach(unitGroup => {
        unitGroup.split('・').forEach(unitName => {
          const trimmedName = unitName.trim();
          if (trimmedName) newUnits.add(trimmedName);
        });
      });
      // ▲▲▲【修正】▲▲▲
      caseObj.backupUnits = Array.from(newUnits);
  }
  
  caseObj.backupUnits = caseObj.backupUnits.filter(bu => bu !== caseObj.unit);

  if (firstNode.params && firstNode.params.escalate_level) {
      const newLevel = parseInt(firstNode.params.escalate_level, 10);
      if (!isNaN(newLevel)) {
          caseObj.level = newLevel;
      }
  }

  this.activeCases.set(caseId, caseObj);
  const context = { unit, zone, type_ja: selectedScenario.name, commander: commanderName };
  let message = this.parser.parse(firstNode.message, context);
  
  return {
    id: `N${String(this.nodeIdCounter++).padStart(6, '0')}`,
    caseId, 
    level: caseObj.level,
    phase: firstNode.phase, zone, unit, message, scenarioName: selectedScenario.name,
    params: firstNode.params
  };
}

progressCase(caseId, busyUnits) {
  console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
  console.log('🔵 progressCase: 開始');
  console.log('  事案ID:', caseId);
  console.log('  isBackupAllActive:', this.isBackupAllActive);
  console.log('  backupAllCaseId:', this.backupAllCaseId);

  // 安全用プロパティ初期化
  if (this.lastBackupAllActivity === undefined) {
    this.lastBackupAllActivity = Date.now();
  }
  if (this.backupAllStallWarned === undefined) {
    this.backupAllStallWarned = false;
  }

  // 対象事案
  const caseObj = this.activeCases.get(caseId);
  if (!caseObj) {
    console.log('  ❌ 事案が見つかりません');
    return null;
  }

  console.log('  📋 現在のフェーズ:', caseObj.phase);
  console.log('  📋 現在のユニット:', caseObj.unit);
  console.log('  📋 現在のバックアップ:', [...caseObj.backupUnits]);

  // いま空いてる応援部隊
  const allBackupUnits = this.unitTypes.backup || [];
  console.log('  📊 全backup_unit:', allBackupUnits);
  console.log('  📊 busyUnits:', Array.from(busyUnits));

  const availableBackupUnits = allBackupUnits.filter(u => !busyUnits.has(u));
  console.log('  ✅ 利用可能なbackup_unit:', availableBackupUnits);
  console.log('  📈 利用可能数:', availableBackupUnits.length);

  // selectNextNode用の状態
  const caseState = {
    id: caseId,
    isNew: false,
    awaitingResponse: caseObj.awaitingResponse,
    elapsed: Math.floor((Date.now() - caseObj.startTime) / 1000),
    hasAvailableBackupUnits: availableBackupUnits.length > 0
  };

  // 次に進むべきノード
  const nextNode = this.selectNextNode(caseObj.currentNode, caseState);
  if (!nextNode) {
    console.log(`  ⏭️ 次のノードがありません (${caseId}) 終了`);

    // この事案が backup-all の本体だった場合は自然終了で解除
    if (this.isBackupAllActive && this.backupAllCaseId === caseId) {
      console.log(`[System] backup-all事案 (${caseId}) が終了。モードを解除します。`);
      this.isBackupAllActive = false;
      this.backupAllCaseId = null;
    }

    this.activeCases.delete(caseId);

    if (caseObj.awaitingResponse) {
      caseObj.awaitingResponse = false;
    }
    return null;
  }

  console.log('  ✅ 次のノード:', nextNode.phase);
  console.log('  📋 nextNode.condition:', nextNode.condition);
  console.log('  📋 nextNode.message:', (nextNode.message || '').substring(0, 80) + '...');
  console.log('  📋 nextNode.params:', nextNode.params);

  // デバッグ用に peek（1手先）だけはログに出しておく（ブロック判定では使わない）
  let peekNode = null;
  try {
    peekNode = this.selectNextNode(nextNode, caseState) || null;
  } catch (e) {
    console.warn('  ⚠️ peekNode取得時に例外:', e);
    peekNode = null;
  }
  if (peekNode) {
    console.log('  🔍 peekNode.phase:', peekNode.phase);
    console.log('  🔍 peekNode.message:', (peekNode.message || '').substring(0, 80) + '...');
    console.log('  🔍 peekNode.params:', peekNode.params);
  } else {
    console.log('  🔍 peekNode: (なし)');
  }

  // ======================================================
  // 待機判定ロジック
  // ======================================================

  // この案件にはすでに応援部隊が張り付いている？
  const caseAlreadyHasBackup = (caseObj.backupUnits && caseObj.backupUnits.length > 0);

  // グローバルで「今すぐ動ける応援」がいる？
  const backupAvailableNow = (availableBackupUnits.length > 0);

  // ①「現場からの初回応援リクエスト」判定
  //
  // まだこの案件に応援がいない状態で、
  // nextNode が「応援ください／至急支援願いたい」系（= 応援要請フェーズ）か？
  //
  // これは dispatcher（本部）ではなく現場側が「応援を要請する」と言っている段階。
  // この段階でも、もう応援が全出払なら無線を流さず足踏みしたい。
  //
  const nodeIsFirstFieldRequest = (node) => {
    if (!node) return false;
    if (caseAlreadyHasBackup) return false; // もう応援が付いてるなら初回要請ではない

    // 判定の軸はフェーズ名 or メッセージ文面
    const phaseSuggestsRequest =
      node.phase && node.phase.includes('応援要請');

    const text = node.message || '';
    const messageSuggestsRequest =
      text.includes('応援を要請') ||
      text.includes('応援要請') ||
      text.includes('至急支援願いたい') ||
      text.includes('支援願いたい') ||
      text.includes('支援要請');

    return phaseSuggestsRequest || messageSuggestsRequest;
  };

  // ②「本部が最初の派遣指示を出す」判定
  //
  // まだこの案件に応援がいない状態で、
  // nextNode が実際に {backup_unit} を呼ぶ or backup-all=true を撃とうとしているなら、
  // それは初回派遣（本部アナウンス）なので止めたい。
  //
  const nodeIsFirstDispatchFromHQ = (node) => {
    if (!node) return false;
    if (caseAlreadyHasBackup) return false; // 既に応援が到着済みなら「2回目以降の呼びかけ」なので止めない

    const mentionsBackupUnitInMessage =
      node.message && node.message.includes('{backup_unit}');
    const isBackupAllCall =
      node.params && node.params['backup-all'] === 'true';

    return (mentionsBackupUnitInMessage || isBackupAllCall);
  };

  const blockFieldRequest   = nodeIsFirstFieldRequest(nextNode);
  const blockHQDispatch     = nodeIsFirstDispatchFromHQ(nextNode);

  // どっちかに該当し、かつ今は空いてる応援がいないなら待機
  //
  // - blockFieldRequest: 「応援を要請する。至急支援願いたい。」←ここで止めたい
  // - blockHQDispatch:   「{backup_unit}、至急現場へ転進せよ。」や「全応援を」←ここでも止めたい
  //
  const shouldStandbyBecauseNoBackup =
    (blockFieldRequest || blockHQDispatch) && !backupAvailableNow;

  if (shouldStandbyBecauseNoBackup) {
    console.log('  ⏸ 応援関連フェーズだが空きなし。待機します。');
    console.log('     (blockFieldRequest=', blockFieldRequest,
                ', blockHQDispatch=', blockHQDispatch, ')');
    return null;
  }

  // ------------------------------------------------------
  // backup-all（全応援招集）中の他案件の足止め
  // ------------------------------------------------------
  //
  // 別の案件が backup-all を走らせている場合、
  // 他の案件が「新しく応援を取りたい / backup-allを新規に宣言したい」
  // という局面に入ろうとしたら待機させる。
  //
  // ただし、既に応援が張り付いてる案件での後続交信
  // （=2回目以降の {backup_unit} 呼びかけ）は止めない。
  //
  const thisNodeIsTryingToGetFreshBackupNow =
    (!caseAlreadyHasBackup) &&
    nextNode.message &&
    nextNode.message.includes('{backup_unit}');

  const thisNodeIsTryingToDeclareBackupAllNow =
    nextNode.params && nextNode.params['backup-all'] === 'true';

  const isRequestingNewBackupOrBackupAll =
    thisNodeIsTryingToGetFreshBackupNow || thisNodeIsTryingToDeclareBackupAllNow;

  if (this.isBackupAllActive &&
      this.backupAllCaseId !== caseId &&
      isRequestingNewBackupOrBackupAll) {

    console.log('  ⏸ backup-all発令中。他案件は待機します。');
    console.log('     優先現場:', this.backupAllCaseId, ' / この事案:', caseId);
    console.log('     (isRequestingNewBackupOrBackupAll=', isRequestingNewBackupOrBackupAll, ')');

    // backup-all本体が長時間動いてないのにロックし続けてるようなら警告だけ出す
    const now = Date.now();
    const stalledMs = now - (this.lastBackupAllActivity || 0);

    if (stalledMs > 90_000 && !this.backupAllStallWarned) {
      console.warn(
        `[Safety] backup-all(${this.backupAllCaseId}) が ${Math.floor(stalledMs / 1000)}秒進行なしのままロック継続中。` +
        `状況確認が必要な可能性があります。`
      );
      this.backupAllStallWarned = true;
    }

    return null;
  }

  // ======================================================
  // ここから先は、進行確定処理
  // ======================================================

  // backup-all の実処理（全隊招集をこの事案が宣言する場合）
  const isBackupAllCallNow =
    nextNode.params && nextNode.params['backup-all'] === 'true';

  console.log('  🚨 isBackupAllCallNow:', isBackupAllCallNow);
  if (isBackupAllCallNow) {
    
    // ▼▼▼【バグ修正】既存のBackup-Allがアクティブな場合の上書き防止 ▼▼▼
    if (this.isBackupAllActive && this.backupAllCaseId !== caseId) {
        console.log(`  ⏸ 既存のbackup-all (${this.backupAllCaseId}) が発令中のため、新規のbackup-all (${caseId}) 宣言を待機します。`);
        return null; // ★ 待機
    }
    // ▲▲▲【バグ修正】ここまで ▲▲▲

    console.log('  ━━━━━━━━━━━━━━━━━━━━━━');
    console.log('  🔴 backup-all発令！');
    console.log('  ━━━━━━━━━━━━━━━━━━━━━━');

    this.isBackupAllActive = true;
    this.backupAllCaseId = caseId;

    console.log('  🔴 isBackupAllActive = true');
    console.log('  🔴 backupAllCaseId =', caseId);

    const beforeBackups = [...caseObj.backupUnits];
    console.log('  📊 発令前のバックアップ:', beforeBackups);

    // まだ入っていない応援ユニットも全部吸い上げる
    const existingBackups = new Set(caseObj.backupUnits);
    availableBackupUnits.forEach(unitName => {
      if (!existingBackups.has(unitName) && unitName !== caseObj.unit) {
        existingBackups.add(unitName);
        console.log('    ➕ 追加:', unitName);
      }
    });
    caseObj.backupUnits = Array.from(existingBackups);

    console.log('  ✅ 発令後のバックアップ:', caseObj.backupUnits);
    console.log('  📈 追加された台数:', caseObj.backupUnits.length - beforeBackups.length);
    console.log('  📊 合計ユニット数:', 1 + caseObj.backupUnits.length);
  }

  // ノード遷移を反映
  caseObj.currentNode = nextNode;
  caseObj.phase = nextNode.phase;

  // レベルエスカレーション
  if (nextNode.params && nextNode.params.escalate_level) {
    const newLevel = parseInt(nextNode.params.escalate_level, 10);
    if (!isNaN(newLevel)) {
      caseObj.level = newLevel;
      console.log('  ⬆️ レベルエスカレート:', newLevel);
    }
  }

  // add_units パラメータでバックアップ隊を追加
  if (nextNode.params && nextNode.params.add_units) {
    const beforeAdd = [...caseObj.backupUnits];
    const newUnits = new Set(caseObj.backupUnits);

    nextNode.params.add_units.split(';').forEach(unitGroup => {
      unitGroup.split('・').forEach(unitName => {
        const trimmedName = unitName.trim();
        if (trimmedName) newUnits.add(trimmedName);
      });
    });

    caseObj.backupUnits = Array.from(newUnits);
    console.log('  ➕ add_units処理');
    console.log('    - 処理前:', beforeAdd);
    console.log('    - 処理後:', caseObj.backupUnits);
  }

  // need-response=true のときは応答待機にする
  if (nextNode.params && nextNode.params['need-response'] === 'true') {
    caseObj.awaitingResponse = true;
    console.log('  ⏸ 応答待機状態に設定');
  } else {
    caseObj.awaitingResponse = false;
  }

  // 無線メッセージで使う context
  const context = {
    unit: caseObj.unit,
    zone: caseObj.zone,
    type_ja: caseObj.scenario.name,
    commander: commanderName
  };

  // {backup_unit} の埋め込み
  if (nextNode.message.includes('{backup_unit}')) {
    let unitToUse = null;

    if (caseObj.backupUnits && caseObj.backupUnits.length > 0) {
      // 既にこの案件に張り付いてる応援を呼ぶ
      unitToUse = caseObj.backupUnits[0];
      console.log('  📋 backup_unit context (既存):', unitToUse);

    } else if (availableBackupUnits.length > 0) {
      // まだ付いてないなら今空いてる応援から新規に割り当て
      const selectedBackupUnit =
        availableBackupUnits[Math.floor(Math.random() * availableBackupUnits.length)];
      caseObj.backupUnits.push(selectedBackupUnit);
      unitToUse = selectedBackupUnit;
      console.log('  ➕ 新しいbackup_unitを割り当て:', selectedBackupUnit);

    } else {
      console.warn(`  ⚠️ backup_unitが必要でしたが、割り当てられませんでした。 (Case: ${caseId}, Node: ${nextNode.phase})`);
    }

    context.backup_unit = unitToUse;

  } else if (caseObj.backupUnits && caseObj.backupUnits.length > 0) {
    // このノード自体は {backup_unit} を含まないが、
    // 既に応援はいるので、その隊名を context に入れておく
    context.backup_unit = caseObj.backupUnits[0];
  }

  // テンプレ展開
  let message = this.parser.parse(nextNode.message, context);

  // backup-all本体が動いたら、その活動時刻を更新＆警告フラグ解除
  if (this.isBackupAllActive && this.backupAllCaseId === caseId) {
    this.lastBackupAllActivity = Date.now();
    this.backupAllStallWarned = false;
  }

  console.log('  ━━━━━━━━━━━━━━━━━━━━━━');
  console.log('  ✅ 事案進行完了');
  console.log('  📋 事案ID:', caseId);
  console.log('  📋 フェーズ:', nextNode.phase);
  console.log('  📋 プライマリユニット:', caseObj.unit);
  console.log('  📋 バックアップユニット:', caseObj.backupUnits);
  console.log('  📋 合計ユニット数:', 1 + caseObj.backupUnits.length);
  console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━');

  return {
    id: `N${String(this.nodeIdCounter++).padStart(6, '0')}`,
    caseId,
    level: caseObj.level,
    phase: nextNode.phase,
    zone: caseObj.zone,
    unit: caseObj.unit,
    message,
    scenarioName: caseObj.scenario.name,
    params: nextNode.params
  };
}
  getAllActiveCases() {
    return Array.from(this.activeCases.values()).filter(c => c.phase !== 'clear');
  }

  getVisibleCases() {
      return this.getAllActiveCases().filter(c => c.isVisible);
  }
}

// ==========================================
// UI更新
// ==========================================

// ▼▼▼【変更】requestAnimationFrameからsetIntervalに変更 ▼▼▼
let timerInterval = null;

function updateTimers() {
  // 既存のタイマーがあれば停止
  if (timerInterval) {
    clearInterval(timerInterval);
  }
  
  // setIntervalで50msごとに更新
  timerInterval = setInterval(() => {
    const now = Date.now();
    document.querySelectorAll('.case-card[data-start-time]').forEach(card => {
      const timeEl = card.querySelector('.case-time');
      const startTime = parseInt(card.dataset.startTime, 10);
      
      if (timeEl && startTime) {
        const elapsedMs = now - startTime;
        const totalSeconds = Math.floor(elapsedMs / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        const centiseconds = Math.floor((elapsedMs % 1000) / 10);
        timeEl.textContent = `${minutes}:${String(seconds).padStart(2, '0')}.${String(centiseconds).padStart(2, '0')}`;
      }
    });
  }, 50);
  
  console.log('✅ タイマー起動（setInterval版）');
}

function stopTimers() {
  if (timerInterval) {
    clearInterval(timerInterval);
    timerInterval = null;
    console.log('⏹️ タイマー停止');
  }
}
// ▲▲▲【変更ここまで】▲▲▲
function updateCaseStatus() {
  const el = document.getElementById("caseList");
  if (!scenarioEngine) {
    el.innerHTML = '<div class="no-cases">CSVファイルを読み込んでください</div>';
    return;
  }
  
  const active = scenarioEngine.getVisibleCases();
  if (active.length === 0) {
    el.innerHTML = '<div class="no-cases">現在、進行中の事案はありません</div>';
    return;
  }

  active.sort((a, b) => b.level - a.level);
  
  // 既存のカードをMapで管理
  const existingCardsMap = new Map();
  el.querySelectorAll('.case-card').forEach(card => {
    const caseId = card.querySelector('.case-id')?.textContent;
    if (caseId) {
      existingCardsMap.set(caseId, card);
    }
  });
  
  const fragment = document.createDocumentFragment();
  
  active.forEach(c => {
    const allUnits = [c.unit, ...c.backupUnits].filter(u => u);
    const unitsStr = allUnits.join('・');
    const levelClass = `lv${c.level}`;
    
    let card = existingCardsMap.get(c.id);
    
    if (card) {
      // 既存カードを更新（case-time以外）
      card.querySelector('.level-badge').className = `level-badge ${levelClass}`;
      card.querySelector('.level-badge').textContent = `LV${c.level}`;
      card.querySelector('.case-type').textContent = c.scenario.name;
      card.querySelector('.case-info-row:nth-child(1) .info-value').textContent = c.zone;
      card.querySelector('.case-info-row:nth-child(2) .info-value').textContent = c.phase;
      card.querySelector('.case-units').textContent = unitsStr;
      // ★ case-timeは触らない！updateTimers()に任せる ★
      
      existingCardsMap.delete(c.id);
    } else {
      // 新規カードを作成
      card = document.createElement('div');
      card.className = 'case-card';
      card.setAttribute('data-start-time', c.startTime);
      card.innerHTML = `
        <div class="case-header">
          <span class="level-badge ${levelClass}">LV${c.level}</span>
          <span class="case-id">${c.id}</span>
          <span class="case-type">${c.scenario.name}</span>
        </div>
        <div class="case-body">
          <div class="case-info-row"><span class="info-label">地区:</span><span class="info-value">${c.zone}</span></div>
          <div class="case-info-row"><span class="info-label">状態:</span><span class="info-value">${c.phase}</span></div>
        </div>
        <div class="case-footer">
          <span class="case-units">${unitsStr}</span>
          <span class="case-time">0:00.00</span>
        </div>
      `;
    }
    
    fragment.appendChild(card);
  });
  
  el.innerHTML = '';
  el.appendChild(fragment);
}

// ==========================================
// ユーティリティ
// ==========================================

const sleep = ms => new Promise(r => setTimeout(r, ms));

async function typeOut(seed, cpsBase, ev, msgEl) {
  const pauses = { ",": 120, "、": 160, ".": 180, "。": 220, " ": 50 };
  const base = 1000 / cpsBase;
  msgEl.textContent = "";

  for (let i = 0; i < ev.message.length; i++) {
    const ch = ev.message[i];
    let extra = pauses[ch] || 0;
    await sleep(base + extra);
    msgEl.textContent += ch;
  }
}

// ==========================================
// 音声関連
// ==========================================

function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    masterGain   = audioCtx.createGain();
    timeSigGain  = audioCtx.createGain(); // ★ 時報用
    sfxGain      = audioCtx.createGain();
    noiseGain    = audioCtx.createGain();

    // ルーティング
    timeSigGain.connect(masterGain); // 時報はここへ
    sfxGain.connect(masterGain);     // 効果音
    noiseGain.connect(masterGain);   // 無線ノイズ
    masterGain.connect(audioCtx.destination);

    // スライダー現在値を反映
    const masterVol   = parseFloat(document.getElementById("masterVolumeSlider").value);
    const timeSigVol  = parseFloat(document.getElementById("timeSigVolumeSlider").value || "0.5");
    const sfxVol      = parseFloat(document.getElementById("sfxVolumeSlider").value);
    const noiseVol    = parseFloat(document.getElementById("noiseVolumeSlider").value);

    masterGain.gain.setValueAtTime(masterVol,  audioCtx.currentTime);
    timeSigGain.gain.setValueAtTime(timeSigVol, audioCtx.currentTime);
    sfxGain.gain.setValueAtTime(sfxVol,        audioCtx.currentTime);
    noiseGain.gain.setValueAtTime(noiseVol,    audioCtx.currentTime);
  }

  if (audioCtx.state === "suspended") {
    audioCtx.resume();
  }
}

function playChirp(type) {
  if (!audioCtx) return;
  const t0 = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'triangle';
  gain.gain.value = 0;

  const vol = 0.05; // 基準音量

  if (type === 'start') {
    osc.frequency.setValueAtTime(250, t0 + 0.12);
    gain.gain.linearRampToValueAtTime(vol, t0 + 0.13);
    gain.gain.linearRampToValueAtTime(0, t0 + 0.17);
    osc.frequency.setValueAtTime(750, t0 + 0.06);
    gain.gain.linearRampToValueAtTime(vol, t0 + 0.07);
    gain.gain.linearRampToValueAtTime(0, t0 + 0.11);
  } else if (type === 'end') {
    osc.frequency.setValueAtTime(1500, t0);
    gain.gain.linearRampToValueAtTime(vol, t0 + 0.01);
    gain.gain.linearRampToValueAtTime(0, t0 + 0.05);
    osc.frequency.setValueAtTime(750, t0 + 0.06);
    gain.gain.linearRampToValueAtTime(vol, t0 + 0.07);
    gain.gain.linearRampToValueAtTime(0, t0 + 0.11);
    osc.frequency.setValueAtTime(250, t0 + 0.12);
    gain.gain.linearRampToValueAtTime(vol, t0 + 0.13);
    gain.gain.linearRampToValueAtTime(0, t0 + 0.17);
  }

  osc.connect(gain);
  // ▼▼▼【変更点】接続先をsfxGainミキサーに変更 ▼▼▼
  gain.connect(sfxGain);
  // ▲▲▲【変更点】▲▲▲
  osc.start(t0);
  osc.stop(t0 + 0.2);
}

function startWhiteNoise() {
  if (!audioCtx || whiteNoiseNode) return;
  
  const bufferSize = audioCtx.sampleRate * 1;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const output = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    output[i] = Math.random() * 2 - 1;
  }

  whiteNoiseNode = audioCtx.createBufferSource();
  whiteNoiseNode.buffer = buffer;
  whiteNoiseNode.loop = true;
  
  const gainNode = audioCtx.createGain();
  const lowPassFilter = audioCtx.createBiquadFilter();
  lowPassFilter.type = 'lowpass';
  lowPassFilter.frequency.value = 1500;
  const highPassFilter = audioCtx.createBiquadFilter();
  highPassFilter.type = 'highpass';
  highPassFilter.frequency.value = 500;

  whiteNoiseNode.connect(highPassFilter);
  highPassFilter.connect(lowPassFilter);
  lowPassFilter.connect(gainNode);
  // ▼▼▼【変更点】接続先をnoiseGainミキサーに変更 ▼▼▼
  gainNode.connect(noiseGain);
  // ▲▲▲【変更点】▲▲▲
  
  gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
  // フェードインはここで行う（基準音量まで）
  gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 1);
  
  whiteNoiseNode.start();
}

function stopWhiteNoise() {
  return new Promise(resolve => {
    if (!whiteNoiseNode) {
      resolve();
      return;
    }
    // 即時停止ではなく、フェードアウトさせるために新しいGainNodeを使う
    const fadeOutGain = audioCtx.createGain();
    fadeOutGain.connect(noiseGain); // 接続先はnoiseGainのまま
    
    const currentGain = 0.01; // startWhiteNoiseの最大音量に合わせる
    fadeOutGain.gain.setValueAtTime(currentGain, audioCtx.currentTime);
    fadeOutGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05);

    try {
        whiteNoiseNode.disconnect();
        whiteNoiseNode.connect(fadeOutGain);
    } catch (e) { /* ignore */ }

    setTimeout(() => {
      try {
        whiteNoiseNode.stop();
      } catch (e) { /* ignore */ }
      whiteNoiseNode = null;
      resolve();
    }, 50);
  });
}

function toneNTT(kind) {
  if (!TTS_ENABLED || !audioCtx) return;

  const p = {
    pip:  { f: 2000, dur: 4,   g: 0.03, atk: 0.001, dec: 0.030, rel: 0.030, h2: 0.3 },
    pop:  { f: 500,  dur: 100, g: 0.06, atk: 0.001, dec: 0.050, rel: 0.060, h2: 1   },
    peen: { f: 1000, dur: 600, g: 0.06, atk: 0.003, dec: 0.01,  rel: 0.003, h2: 1   }
  }[kind];

  const ctx = audioCtx;
  const t0 = ctx.currentTime;

  const osc = ctx.createOscillator();
  osc.type = 'square';
  osc.frequency.value = p.f;

  const gain = ctx.createGain();
  gain.gain.value = 0;

  const filter = ctx.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = p.f * 1.4;

  osc.connect(filter);
  filter.connect(gain);

  // ★ ここが変更ポイント：時報専用のバスへ
  gain.connect(timeSigGain);

  // エンベロープ
  const g = gain.gain;
  g.setValueAtTime(0, t0);
  g.linearRampToValueAtTime(p.g,           t0 + p.atk);
  g.linearRampToValueAtTime(p.g * 0.8,     t0 + p.atk + p.dec);
  g.linearRampToValueAtTime(0.0001,        t0 + (p.dur / 1000) + p.rel);

  osc.start(t0);
  osc.stop(t0 + (p.dur / 1000) + p.rel + 0.05);
}
// ▼▼▼【変更】引数にshowOverlayを追加 ▼▼▼
function playEmergencyBeep(durationMs, showOverlay = true) {
  if (!TTS_ENABLED || !audioCtx) return Promise.resolve();
  ensureAudio();

  // ▼▼▼【変更】showOverlayがtrueの時のみ警告画面を表示 ▼▼▼
  const overlay = document.getElementById('emergency-overlay');
  if (showOverlay) {
    overlay.classList.add('active');
  }
  // ▲▲▲【変更】ここまで ▲▲▲

  return new Promise(resolve => {
    const t0 = audioCtx.currentTime;
    const durationSec = durationMs / 1000;

    const mainGain = audioCtx.createGain();
    mainGain.connect(sfxGain);
    mainGain.gain.value = 0;

    const osc1 = audioCtx.createOscillator();
    const osc2 = audioCtx.createOscillator();
    osc1.type = 'sine';
    osc2.type = 'sine';
    osc1.frequency.setValueAtTime(1000, t0);
    osc2.frequency.setValueAtTime(1030, t0);
    osc1.connect(mainGain);
    osc2.connect(mainGain);

    const attackTime = 0.005;
    const releaseTime = 0.01;
    const vol = 0.02; // 基準音量
    mainGain.gain.linearRampToValueAtTime(vol, t0 + attackTime);
    mainGain.gain.setValueAtTime(vol, t0 + durationSec - releaseTime);
    mainGain.gain.linearRampToValueAtTime(0, t0 + durationSec);

    osc1.start(t0);
    osc2.start(t0);
    osc1.stop(t0 + durationSec);
    osc2.stop(t0 + durationSec);

    osc2.onended = () => {
      // ▼▼▼【変更】showOverlayがtrueの時のみ警告画面を非表示 ▼▼▼
      if (showOverlay) {
        overlay.classList.remove('active');
      }
      // ▲▲▲【変更】ここまで ▲▲▲
      resolve();
    };
  });
}
function startTimeSignal() {
  if (tickTimer) clearTimeout(tickTimer);
  if (!TTS_ENABLED) return;
  ensureAudio();

  const tick = () => {
    if (!TTS_ENABLED) { 
      tickTimer = null;
      return;
    }
    const s = new Date().getSeconds();
    if (s % 10 === 0) { toneNTT('peen'); }
    else if (s >= 57) { toneNTT('pop'); }
    else { toneNTT('pip'); }
    const delay = 1000 - new Date().getMilliseconds();
    tickTimer = setTimeout(tick, delay);
  };
  const firstDelay = 1000 - new Date().getMilliseconds();
  tickTimer = setTimeout(tick, firstDelay);
}

function stopTimeSignal() {
  if (tickTimer) {
    clearTimeout(tickTimer);
    tickTimer = null;
  }
}

// ==========================================
// 時計
// ==========================================
(function () {
  const el = document.getElementById("jst");
  function pad(n, len = 2) { return String(n).padStart(len, "0"); }
  function tick() {
    const now = new Date();
    const ms = String(now.getMilliseconds()).padStart(3, '0');
    el.textContent = `${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}.${ms}`;
  }
  tick();
  setInterval(tick, 50);
})();

// ==========================================
// 自動スクロール制御
// ==========================================
(function() {
  const log = document.getElementById("log");
  let scrollAnimationFrame = null;
  const SCROLL_SPEED = 0.5; // ピクセル/フレーム（この値を調整して速度変更）
  let userScrolling = false;
  let scrollTimeout = null;
  let isAutoScrolling = false;
 
  function smoothScrollToBottom() {
    if (userScrolling) return;
    
    isAutoScrolling = true;
    const targetScroll = log.scrollHeight - log.clientHeight;
    const currentScroll = log.scrollTop;
    const distance = targetScroll - currentScroll;
   
    if (Math.abs(distance) < 1) {
      log.scrollTop = targetScroll;
      scrollAnimationFrame = null;
      isAutoScrolling = false;
      return;
    }
   
    // 一定速度でスクロール（速度は固定）
    log.scrollTop = currentScroll + Math.min(SCROLL_SPEED, distance);
   
    scrollAnimationFrame = requestAnimationFrame(smoothScrollToBottom);
  }
 
  function resetAutoScroll() {
    userScrolling = false;
    if (scrollAnimationFrame) {
      cancelAnimationFrame(scrollAnimationFrame);
    }
   
    // 速度計算せず、固定速度でスクロール開始
    smoothScrollToBottom();
  }
  
  // 新しいログが追加されたときの処理
  const observer = new MutationObserver(() => {
    // ユーザーがスクロール中でなく、かつ既に自動スクロール中なら継続
    // ユーザーがスクロール中でなく、自動スクロールもしていなければ開始
    if (!userScrolling && !scrollAnimationFrame) {
      smoothScrollToBottom();
    }
    // 既にスクロール中なら何もしない（固定速度を維持）
  });
  
  observer.observe(log, { childList: true, subtree: true });
 
  log.addEventListener('wheel', () => {
    userScrolling = true;
    clearTimeout(scrollTimeout);
    if (scrollAnimationFrame) {
      cancelAnimationFrame(scrollAnimationFrame);
      scrollAnimationFrame = null;
    }
    isAutoScrolling = false;
    scrollTimeout = setTimeout(resetAutoScroll, 5000);
  });
 
  let touchStartY = 0;
  let hasMoved = false;

  // touchstartでは userScrolling = true にしない！
  log.addEventListener('touchstart', (e) => {
    touchStartY = e.touches[0].clientY;
    hasMoved = false;
    // userScrolling はここで設定しない
  });

  // touchmoveで実際にスクロールした時だけ設定
  log.addEventListener('touchmove', (e) => {
    const deltaY = e.touches[0].clientY - touchStartY;
    if (Math.abs(deltaY) > 5) { // 5px以上の移動でスクロールとみなす
      userScrolling = true;  // ← ここで初めて設定
      hasMoved = true;
    }
  });

  // touchendでスクロールしていない場合は何もしない
  log.addEventListener('touchend', () => {
    if (hasMoved) {  // ← スクロールした場合のみ
      clearTimeout(scrollTimeout); // 既存のタイマーをクリア
      scrollTimeout = setTimeout(resetAutoScroll, 5000);
    }
    // スクロールしてなければ自動スクロール継続
  });
 
  log.addEventListener('mousedown', () => { // マウスドラッグ開始
      userScrolling = true;
      clearTimeout(scrollTimeout);
      if (scrollAnimationFrame) {
          cancelAnimationFrame(scrollAnimationFrame);
          scrollAnimationFrame = null;
      }
      isAutoScrolling = false;
  });

  log.addEventListener('mouseup', () => {
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(resetAutoScroll, 5000);
  });
})();
// ==========================================
// 音声合成（TTS）
// ==========================================

function loadVoices() {
  if (!('speechSynthesis' in window)) return;
  const load = () => {
    const vs = speechSynthesis.getVoices();
    const sel = document.getElementById("voiceSel");
    sel.innerHTML = '<option value="">声の種類</option>';
    vs.forEach((v, i) => {
      const o = document.createElement('option');
      o.value = String(i); o.textContent = `${v.name} (${v.lang})`;
      sel.appendChild(o);
    });
    const jaVoice = vs.find(v => /^ja/i.test(v.lang)) || vs[0];
    chosenVoice = jaVoice;
  };
  load();
  speechSynthesis.onvoiceschanged = load;
}
loadVoices();

async function speakMessage(text, isTest = false) {
  return new Promise((resolve) => {
    // 少し待ってから処理（元の構造維持）
    setTimeout(() => {
      if (!('speechSynthesis' in window)) {
        resolve();
        return;
      }

      // 1. UIの現在値で毎回最新状態を確定させる
      // rate
      const rateSliderEl = document.getElementById("rateSlider");
      if (rateSliderEl) {
        const r = parseFloat(rateSliderEl.value);
        if (!isNaN(r)) ttsRate = r;
      }

      // TTSボリューム
      const ttsVolumeSliderEl = document.getElementById("ttsVolumeSlider");
      if (ttsVolumeSliderEl) {
        const tv = parseFloat(ttsVolumeSliderEl.value);
        if (!isNaN(tv)) ttsVolume = tv;
      }

      // masterVolume
      let masterVol = 1.0;
      if (typeof masterGain !== "undefined" && masterGain) {
        masterVol = masterGain.gain.value;
      } else {
        const mvEl = document.getElementById("masterVolumeSlider");
        if (mvEl) {
          const mv = parseFloat(mvEl.value);
          if (!isNaN(mv)) masterVol = mv;
        }
      }

      // voice選択（ここがiOSの外国語読み対策）
      const voiceSelectEl = document.getElementById("voiceSel");
      if (voiceSelectEl) {
        const allVoices = speechSynthesis.getVoices();
        const idx = parseInt(voiceSelectEl.value);

        if (!isNaN(idx) && allVoices[idx]) {
          chosenVoice = allVoices[idx];
        } else {
          chosenVoice =
            chosenVoice ||
            allVoices.find(v => /^ja/i.test(v.lang)) ||
            allVoices[0] ||
            null;
        }
      } else {
        // voiceSelそのものがない場合のフォールバック
        const allVoices = speechSynthesis.getVoices();
        if (!chosenVoice && allVoices.length > 0) {
          chosenVoice =
            allVoices.find(v => /^ja/i.test(v.lang)) ||
            allVoices[0] ||
            null;
        }
      }

      // 2. 発話オブジェクト作成
      const utter = new SpeechSynthesisUtterance(text);

      // iOSはvoiceが不正参照だと無視されて英語固定になったりする。
      // 常に「いまの chosenVoice か null」に限定する。
      utter.voice = chosenVoice || null;

      utter.rate = ttsRate;
      utter.volume = ttsVolume * masterVol;

      // 3. コールバック
      utter.onend = () => {
        resolve();
      };

      utter.onerror = (e) => {
        // iOS Safari はユーザーの割り込み/キャンセルでも onerror に来る。
        // その場合は rejectしたくない（シナリオ止めたくない）ので resolve 扱いにする。
        console.warn("SpeechSynthesisUtterance.onerror (treated as resolve)", e);
        resolve();
      };

      // 4. Safari安定化のために僅かな遅延を入れて speak()
      setTimeout(() => {
        // 再生を開始
        speechSynthesis.speak(utter);
      }, 50);

    }, 50);
  });
}

/// ==========================================
// メインループ
// ==========================================

async function runSystem() {
  if (!scenarioEngine) {
    alert('CSVファイルを先に読み込んでください');
    return;
  }
  const status = document.getElementById("status");
  const log = document.getElementById("log");
  const my = ++runningToken;
  log.innerHTML = "";
  scenarioEngine.activeCases.clear();
  scenarioEngine.caseIdCounter = 1;
  scenarioEngine.nodeIdCounter = 1;
  // システム開始時にbackup-all状態をリセット
  if (scenarioEngine) {
    scenarioEngine.isBackupAllActive = false;
    scenarioEngine.backupAllCaseId = null;
  }
  status.textContent = "ACTIVE";
  
  let pendingResponseCaseId = null; 

  async function processAndDisplayEvent(event) {
  if (!event) return;
  
  const randomDelay = Math.random() * 2000 + 2000;
  await sleep(randomDelay);

  const caseObj = scenarioEngine.activeCases.get(event.caseId);
  const isNewCase = caseObj && !caseObj.isVisible;

  // ★★★ 修正：新規事案の場合は、メッセージ表示前にCasePanelを更新しない ★★★
  if (!isNewCase) {
      updateCaseStatus();
  }

  const row = document.createElement("div");
  row.className = "radio-message";
  if (event.params && event.params.alert === 'beep') {
    row.classList.add('alert');
  }
  const meta = document.createElement("div");
  meta.className = "radio-message-meta";
  const ts = document.createElement("div");
  ts.className = "msg-time";
  const ts_now = new Date();
  ts.textContent = ts_now.toLocaleTimeString("ja", { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
  const ch = document.createElement("div");
  ch.className = `msg-level lv${event.level}`;
  ch.textContent = `LV${event.level}`;
  const caseTag = document.createElement("div");
  caseTag.className = "msg-case";
  caseTag.textContent = event.caseId;
  meta.append(ts, ch, caseTag);
  const msg = document.createElement("div");
  msg.className = "msg-content";
  row.append(meta, msg);
  log.appendChild(row);

  if (event.params && event.params.alert === 'beep' && TTS_ENABLED) {
      await playEmergencyBeep(3000);
      await sleep(500);
  }
  if (TTS_ENABLED) {
    ensureAudio();
    playChirp('start');
    startWhiteNoise();
  }
  
  // ★★★ 削除：ここでisNewCaseの処理をしない（メッセージ表示後に移動）★★★
  // if (isNewCase) {
  //     caseObj.isVisible = true;
  //     updateCaseStatus();
  // }

  // ★★★ メッセージ表示（typeOut + TTS） ★★★
  if (TTS_ENABLED) {
    await Promise.all([
      typeOut("", BASE_CPS, event, msg),
      speakMessage(event.message)
    ]);
  } else {
    await typeOut("", BASE_CPS, event, msg);
  }
  if (TTS_ENABLED) {
    await stopWhiteNoise();
    if (TTS_ENABLED) {
      playChirp('end');
    }
  }

  // ★★★ 追加：メッセージ表示完了後に新規事案をCasePanelに表示 ★★★
  if (isNewCase) {
      caseObj.isVisible = true;
      updateCaseStatus();
  }

  if (event.params && event.params['need-response'] === 'true') {
      pendingResponseCaseId = event.caseId;
  }

  // ★★★ 追加：既存事案の場合もメッセージ表示後にCasePanelを更新 ★★★
  // （backup-all途中発令などで変更があった場合に反映）
  if (!isNewCase) {
      updateCaseStatus();
  }

  // ▼▼▼【変更】clear=true関連のロジックをすべて削除 ▼▼▼
  // (終了処理は progressCase 内に移動したため)
  // ▲▲▲【変更ここまで】▲▲▲
  
}

  updateCaseStatus();

  while (my === runningToken) {
    let eventToProcess = null;
    
    // ▼▼▼【修正】busyUnits の計算ロジックを修正 ▼▼▼
    const busyUnits = new Set();
    for (const caseObj of scenarioEngine.activeCases.values()) {
        busyUnits.add(caseObj.unit);
        // forEach を使って全ユニットを Set に追加
        caseObj.backupUnits.forEach(unit => busyUnits.add(unit));
    }
    // ▲▲▲【修正ここまで】▲▲▲
    
    if (pendingResponseCaseId) {
      eventToProcess = scenarioEngine.progressCase(pendingResponseCaseId, busyUnits);
      if (eventToProcess) {
        pendingResponseCaseId = null;
      }
    } 
    
    if (!eventToProcess) {
      const activeCases = scenarioEngine.getVisibleCases();
      const activeCaseCount = activeCases.length;

      if (activeCaseCount < 5 && Math.random() < 0.5 ) {
        eventToProcess = scenarioEngine.generateNewCase(busyUnits);
      }

      if (!eventToProcess && activeCaseCount > 0) {
        let caseIdToProgress = null;
        activeCases.sort((a, b) => a.startTime - b.startTime);
        
        const oldestCase = activeCases[0];
        const otherCases = activeCases.slice(1);

        if (Math.random() < 0.1) {
          caseIdToProgress = oldestCase.id;
        } else {
          if (otherCases.length > 0) {
            const randomOtherCase = otherCases[Math.floor(Math.random() * otherCases.length)];
            caseIdToProgress = randomOtherCase.id;
          } else {
            caseIdToProgress = oldestCase.id;
          }
        }
        
        if (caseIdToProgress) {
            eventToProcess = scenarioEngine.progressCase(caseIdToProgress, busyUnits);
        }
      }
    }

    if (eventToProcess) {
      await processAndDisplayEvent(eventToProcess);
    } else {
      updateCaseStatus();
      await sleep(1000); 
    }
  }
}

// ==========================================
// イベントリスナー
// ==========================================
function initializeSystem(csvText) {
  // シナリオローダーを作成して CSV をパース
  scenarioLoader = new ScenarioLoader();
  try { // ★★★ パース失敗をキャッチ ★★★
    scenarioLoader.parseCSV(csvText);  // PARAM/LEVEL/NODE を取り込む
  } catch (e) {
    console.error("CSVのパースに失敗:", e);
    document.getElementById("caseList").innerHTML =
      '<div class="no-cases">❌ CSVの解析に失敗しました。書式を確認してください。</div>';
    return; // ★★★ここで中断
  }

  // ユニット種別テーブルを構築（CSVの PARAM lists を利用）
  const unitTypes = {
    investigation: scenarioLoader.paramLists.units_investigation || [],
    traffic:       scenarioLoader.paramLists.units_traffic       || [],
    patrol:        scenarioLoader.paramLists.units_patrol        || [],
    backup:        scenarioLoader.paramLists.units_backup        || []
  };

  console.log('--- DEBUG: initializeSystem ---');
  console.log('読み込まれた unitTypes.backup:', unitTypes.backup);
  console.log('---------------------------------');

  // エンジンを初期化
  scenarioEngine = new ScenarioEngine(scenarioLoader, unitTypes);

  // UI: 再読み込みボタンを有効化し、案内メッセージを表示
  document.getElementById("syncBtn").disabled = false;
  document.getElementById("caseList").innerHTML =
    '<div class="no-cases">✅ シナリオ読込完了。システムを起動してください</div>';
}

// ==========================================
// DOMContentLoaded - 初期化と自動起動
// ==========================================
window.addEventListener('DOMContentLoaded', async () => {
  // --- 1. 設定を復元 ---
  loadSettings();

  // --- 2. UIイベント ---
  const commanderInput = document.getElementById("commanderInput");
  commanderInput.addEventListener('input', (e) => {
    const newName = e.target.value.trim();
    commanderName = newName || "本部";
    systemTitle.textContent = `${commanderName}通信指令シミュレータ`;
    saveSettings();
  });

  const specialAlertModeBtn = document.getElementById("specialAlertModeToggle");
  if (specialAlertModeBtn) {
    specialAlertModeBtn.addEventListener("click", () => {
      isSpecialAlertMode = !isSpecialAlertMode;
      specialAlertModeBtn.textContent = `ドラマチックモード: ${isSpecialAlertMode ? "ON" : "OFF"}`;
      specialAlertModeBtn.classList.toggle("active", isSpecialAlertMode);
      saveSettings();
      if (TTS_ENABLED) {
        ensureAudio();
        if (isSpecialAlertMode) { playEmergencyBeep(400, false); }
        else { playChirp('end'); }
      }
    });
  }

  document.getElementById("toggleControls").addEventListener("click", () => {
    document.getElementById("controlPanel").classList.toggle("is-open");
  });
  document.getElementById("closeControlsBtn").addEventListener("click", () => {
    document.getElementById("controlPanel").classList.remove("is-open");
  });

  document.getElementById("voiceSel").addEventListener('change', () => {
    const vs = speechSynthesis.getVoices();
    const i = parseInt(document.getElementById("voiceSel").value);
    chosenVoice = Number.isInteger(i) ? vs[i] : vs.find(v => /^ja/i.test(v.lang));
    saveSettings();
  });

  const rateSlider = document.getElementById("rateSlider");
  rateSlider.addEventListener('input', (e) => {
    ttsRate = parseFloat(e.target.value);
    document.getElementById("rateValue").textContent = ttsRate.toFixed(1);
    saveSettings();
  });
  rateSlider.addEventListener('change', () => {
    if ('speechSynthesis' in window) {
      speechSynthesis.cancel();
      speakMessage("速度テスト", true);
    }
  });

  document.getElementById("masterVolumeSlider").addEventListener('input', (e) => {
    const vol = parseFloat(e.target.value);
    document.getElementById("masterVolumeValue").textContent = vol.toFixed(2);
    if (masterGain) {
      masterGain.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.01);
    }
    saveSettings();
  });

  const sfxSlider = document.getElementById("sfxVolumeSlider");
  sfxSlider.addEventListener('input', (e) => {
    const vol = parseFloat(e.target.value);
    document.getElementById("sfxVolumeValue").textContent = vol.toFixed(2);
    if (sfxGain) {
      sfxGain.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.01);
    }
    saveSettings();
  });
  sfxSlider.addEventListener('change', () => {
    ensureAudio();
    playEmergencyBeep(1000, false);
  });

  const timeSigSlider = document.getElementById("timeSigVolumeSlider");
  timeSigSlider.addEventListener('input', (e) => {
    const vol = parseFloat(e.target.value);
    document.getElementById("timeSigVolumeValue").textContent = vol.toFixed(2);
    if (timeSigGain) {
      timeSigGain.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.01);
    }
    saveSettings();
  });
  timeSigSlider.addEventListener('change', () => {
    // TTSがONのときだけ、"ピッ" を1回鳴らして確認できるようにする
    ensureAudio();
    toneNTT('pip');
  });

  document.getElementById("noiseVolumeSlider").addEventListener('input', (e) => {
    const vol = parseFloat(e.target.value);
    document.getElementById("noiseVolumeValue").textContent = vol.toFixed(2);
    if (noiseGain) {
      noiseGain.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.01);
    }
    saveSettings();
  });

  const ttsSlider = document.getElementById("ttsVolumeSlider");
  ttsSlider.addEventListener('input', (e) => {
    const vol = parseFloat(e.target.value);
    document.getElementById("ttsVolumeValue").textContent = vol.toFixed(2);
    ttsVolume = vol;
    saveSettings();
  });
  ttsSlider.addEventListener('change', () => {
    // いきなり喋らせず、最後の操作から少し落ち着いたら1回だけ喋る
    if (ttsTestTimer) {
      clearTimeout(ttsTestTimer);
      clearTimeout(ttsTestTimer);
    }
    ttsTestTimer = setTimeout(async () => {
      if ('speechSynthesis' in window && TTS_ENABLED) {
        try {
          // OFF中は喋らない、ONなら1回だけテスト
          speechSynthesis.cancel();
          await speakMessage("音量テスト", true);
        } catch (err) {
          console.warn("TTS test speak failed:", err);
        }
      }
    }, 200); // 200msくらいで十分
  });


  // ▼▼▼【ここに追加】ブラウザリロード時のTTSキャンセル ▼▼▼
  window.addEventListener('beforeunload', () => {
    // ブラウザのリロードやページ離脱時にTTSを強制キャンセル
    if ('speechSynthesis' in window) {
      speechSynthesis.cancel();
    }
  });
  // ▲▲▲【追加ここまで】▲▲▲

  // --- 3. シナリオ読み込み → 初期化 → 常に自動起動 ---
  try {
    // キャッシュを完全に回避するためのタイムスタンプ付き
    const cacheBuster = `v=${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const response = await fetch(`scenario.csv?${cacheBuster}`, { 
      cache: 'no-store',
      headers: {
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache'
      }
    });
    
    if (response.ok) {
      const csvText = await response.text();
      initializeSystem(csvText);
      
      // ▼▼▼ 【重要】シナリオ読み込み成功後、必ず自動起動 ▼▼▼
      if (scenarioEngine) { // ★★★ initializeSystemが成功した場合のみ起動 ★★★
        console.log('[System] Auto-starting system...');
        updateTimers(); // ← ここに移動（runSystemの前）
        await runSystem();
      }
    } else {
      document.getElementById("caseList").innerHTML =
        '<div class="no-cases">❌ scenario.csvの読込に失敗しました。</div>';
    }
  } catch (fetchError) {
    console.error('[System] Failed to load scenario:', fetchError);
    document.getElementById("caseList").innerHTML =
      '<div class="no-cases">❌ scenario.csvの読込に失敗しました。</div>';
  }
});

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js')
      .then(reg => console.log('Service Worker registered'))
      .catch(err => console.log('Service Worker registration failed'));
  });
}

</script>
</body>
</html>