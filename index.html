<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>通信指令観測システム</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=M+PLUS+1p:wght@400;500;700&display=swap" rel="stylesheet">
<style>
@font-face {
  font-family: 'DSEG7';
  src: url('DSEG7ClassicMini-Bold.woff') format('woff');
}
:root{
  --bg-primary:#1a1a1a;
  --bg-secondary:#242424;
  --bg-tertiary:#2e2e2e;
  --border:#3a3a3a;
  --text-primary:#e0e0e0;
  --text-secondary:#a0a0a0;
  --text-muted:#707070;
  --accent-blue:#e0e0e0;
  --accent-cyan:#e0e0e0;
  --lv1:#4caf50;
  --lv2:#ff9800;
  --lv3:#f44336;
  --lv4:#9c27b0;
}
html, body {
  height: 100%;
  margin: 0;
  overflow: hidden;
}
*{box-sizing:border-box}
body{
  background:var(--bg-primary);
  color:var(--text-primary);
  font:14px/1.6 'M PLUS 1p', sans-serif;
  display: grid;
  grid-template-rows: auto auto 1fr; /* ヘッダー(auto), 操作パネル(auto), メイン(残り全部) */
}
.system-header{
  background:var(--bg-secondary);
  border-bottom:2px solid var(--border);
  padding:16px 24px;
}
.header-row{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:20px;
  flex-wrap:wrap;
}
.system-title{
  font-size:18px;
  font-weight:700;
  color:var(--accent-cyan);
  letter-spacing:1px;
  text-transform:uppercase;
}
.system-clock{
  font-size:20px;
  font-weight:700;
  color:var(--lv2); /* 色を変更 */
  font-family:'DSEG7', monospace;
  letter-spacing:0.5px;
}
.system-status {
  display: none;
}
.control-panel{
  background:var(--bg-secondary);
  border-bottom:1px solid var(--border);
  padding:12px 24px;
  transition: all 0.3s ease-in-out; /* トグル時のアニメーション */
}
.control-panel.hidden {
  height: 0;
  padding-top: 0;
  padding-bottom: 0;
  border: none;
  overflow: hidden;
}
.control-row{
  display:flex;
  align-items:center;
  gap:12px;
  flex-wrap:wrap;
}
.btn{
  padding:8px 20px;
  background:var(--bg-tertiary);
  border:1px solid var(--border);
  border-radius:4px;
  color:var(--text-primary);
  font:12px/1.4 'M PLUS 1p', sans-serif;
  font-weight:500;
  cursor:pointer;
  transition:all 0.2s;
  letter-spacing:0.5px;
  text-transform:uppercase;
}
.btn:hover{
  background:var(--bg-primary);
  border-color:var(--accent-blue);
  color:var(--accent-blue);
}
.btn.primary{
  background:var(--accent-blue);
  border-color:var(--accent-blue);
  color:#000;
  font-weight:700;
}
.btn.active{
  background:var(--accent-cyan);
  border-color:var(--accent-cyan);
  color:#000;
  font-weight:700;
}
.location-input{
  padding: 8px 12px;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--text-primary);
  font: 12px/1.4 'M PLUS 1p', sans-serif;
  min-width: 160px;
  height: 34px;
}
.location-input:focus{
  outline:none;
  border-color:var(--accent-blue);
}
select{
  padding:8px 12px;
  background:var(--bg-tertiary);
  border:1px solid var(--border);
  border-radius:4px;
  color:var(--text-primary);
  font:12px/1.4 'M PLUS 1p', sans-serif;
  cursor:pointer;
  min-width:200px;
}
.main-content{
  display:grid;
  grid-template-columns:400px 1fr;
  gap:0;
  overflow: hidden;
}
.case-panel{
  background:var(--bg-secondary);
  border-right:2px solid var(--border);
  display:flex;
  flex-direction:column;
  min-height: 0;
}
.panel-header{
  padding:16px 20px;
  border-bottom:1px solid var(--border);
  background:var(--bg-tertiary);
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.panel-title{
  font-size:13px;
  font-weight:700;
  color:var(--accent-cyan);
  letter-spacing:1px;
  text-transform:uppercase;
}
.rate-slider{
  display:flex;
  align-items:center;
  gap:10px;
  padding:8px 16px;
  background:var(--bg-tertiary);
  border:1px solid var(--border);
  border-radius:4px;
}
.rate-slider label{
  font-size:11px;
  color:var(--text-muted);
  letter-spacing:0.5px;
}
.rate-slider input[type="range"]{
  -webkit-appearance: none;
  appearance: none;
  width:100px;
  height:4px;
  background:var(--border);
  outline:none;
  border-radius:2px;
}
.rate-slider input[type="range"]::-webkit-slider-thumb{
  -webkit-appearance: none;
  appearance: none;
  width:16px;
  height:16px;
  background:var(--accent-blue);
  border-radius:50%;
  cursor:pointer;
}
.rate-slider .value{
  font-weight:700;
  color:var(--accent-blue);
  min-width:35px;
  text-align:right;
}
.case-list{
  flex:1;
  overflow-y:auto;
  overflow-x:hidden;
  padding-bottom:20px;
}
.case-card{
  padding:16px 20px;
  border-bottom:1px solid var(--border);
  transition:background 0.2s;
}
.case-card:hover{
  background:var(--bg-tertiary);
}
.case-header{
  display:flex;
  align-items:center;
  gap:10px;
  margin-bottom:8px;
}
.level-badge{
  padding:4px 10px;
  border-radius:3px;
  font-size:11px;
  font-weight:700;
  letter-spacing:0.5px;
}
.level-badge.lv1{background:var(--lv1);color:#000}
.level-badge.lv2{background:var(--lv2);color:#000}
.level-badge.lv3{background:var(--lv3);color:#fff}
.level-badge.lv4{background:var(--lv4);color:#fff}
.case-id{
  font-size:13px;
  font-weight:700;
  color:var(--accent-blue);
}
.case-type{
  font-size:12px;
  color:var(--text-primary);
  margin-left:auto;
}
.case-body{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:8px;
  font-size:11px;
  color:var(--text-secondary);
}
.case-info-row{
  display:flex;
  gap:6px;
}
.info-label{
  color:var(--text-muted);
}
.info-value{
  color:var(--text-secondary);
  font-weight:500;
}
.case-footer{
  margin-top:8px;
  padding-top:8px;
  border-top:1px solid var(--border);
  display:flex;
  justify-content:space-between;
  align-items:center;
  font-size:11px;
}
.case-units{
  color:var(--accent-cyan);
  font-weight:500;
}
.case-time, .msg-time{
  color:var(--text-muted);
  font-family:'M PLUS 1p', sans-serif;
}
.radio-panel{
  background:var(--bg-primary);
  display:flex;
  flex-direction:column;
  min-height: 0;
}
.radio-log{
  flex:1;
  overflow-y:auto;
  overflow-x:hidden;
  padding:12px;
  padding-bottom:40px;
}
.radio-message{
  display:flex;
  flex-direction:column;
  gap:6px;
  padding:12px 16px;
  margin-bottom:8px;
  background:var(--bg-secondary);
  border-left:3px solid transparent;
  border-radius:4px;
  transition:all 0.2s;
  opacity:0;
  transform:translateY(10px);
  animation:slideIn 0.3s ease-out forwards;
}
@keyframes slideIn{
  to{
    opacity:1;
    transform:translateY(0);
  }
}
.radio-message:hover{
  background:var(--bg-tertiary);
  border-left-color:#808080;
}
.radio-message-meta{
  display:flex;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
}
.msg-level{
  padding:4px 8px;
  border-radius:3px;
  font-size:11px;
  font-weight:700;
  text-align:center;
  letter-spacing:0.5px;
  color:var(--text-muted);
}
.msg-case{
  font-size:11px;
  font-weight:700;
  color:var(--text-muted);
}
.msg-content{
  font:13px/1.7 'M PLUS 1p', sans-serif;
  color:var(--text-primary);
  word-break:break-word;
  padding-top:4px;
}
.no-cases{
  padding:40px 20px;
  text-align:center;
  color:var(--text-muted);
  font-size:12px;
}
::-webkit-scrollbar{width:8px;height:8px}
::-webkit-scrollbar-track{background:var(--bg-primary)}
::-webkit-scrollbar-thumb{background:var(--border);border-radius:4px}
::-webkit-scrollbar-thumb:hover{background:var(--text-muted)}
@media (max-width: 768px) {
  .main-content{
    grid-template-columns:1fr;
    grid-template-rows:auto 1fr;
  }
  .case-panel{
    border-right:none;
    border-bottom:2px solid var(--border);
    max-height:35vh;
  }
}
</style>
</head>
<body>

<div class="system-header">
  <div class="header-row">
    <div class="system-title" id="systemTitle">通信指令観測システム（CSV駆動版）</div>
    <div class="system-clock" id="jst">--:--:--.-- JST</div>
    <div class="system-status" id="status">STANDBY</div>
    <button id="toggleControls" class="btn">操作パネル</button>
  </div>
</div>

<div class="control-panel" id="controlPanel">
  <div class="control-row">
    <input type="text" id="locationInput" class="location-input" value="本部">
    <button id="syncBtn" class="btn primary" disabled>システム起動</button>
    <button id="ttsToggle" class="btn">音声: OFF</button>
    <select id="voiceSel"><option value="">音声自動選択</option></select>
    <div class="rate-slider">
      <label>速度:</label>
      <input type="range" id="rateSlider" min="0.5" max="2.0" step="0.1" value="1.2">
      <span class="value" id="rateValue">1.2</span>X
    </div>
  </div>
</div>

<div class="main-content">
  <div class="case-panel">
<div class="panel-header">
  <div class="panel-title">進行中の事案</div>
</div>
    <div class="case-list" id="caseList">
      <div class="no-cases">CSVファイルを読み込んでください</div>
    </div>
  </div>

  <div class="radio-panel">
    <div class="radio-log" id="log"></div>
  </div>
</div>

<script>
// グローバル変数
const BASE_CPS = 12;
let locationName = "本部";
let whiteNoiseNode = null;
let TTS_ENABLED = false;
let chosenVoice = null;
let ttsRate = 1.5;
let audioCtx = null;
let scenarioLoader = null;
let scenarioEngine = null;
let runningToken = 0;
let tickTimer = null;
let userScrolling = false;
let scrollTimeout = null;

// ==========================================
// シナリオCSVローダー
// ==========================================

class ScenarioLoader {
  constructor() {
    this.paramLists = {};
    this.scenarios = [];
    this.scenarioMap = new Map();
  }

  parseCSV(csvText) {
    const lines = csvText.split('\n').filter(line => {
      const trimmed = line.trim();
      return trimmed && !trimmed.startsWith('#');
    });

    let currentLevel = null;
    let currentScenario = null;
    const nodeStack = [];

    for (let i = 1; i < lines.length; i++) {
      const line = lines[i];
      const [section, id, condition, probability, phase, message, params] = 
        this.parseCSVLine(line);

      if (section === 'PARAM') {
        this.paramLists[id] = params ? params.split(';').map(s => s.trim()) : [];
      } 
      else if (section === 'LEVEL') {
        currentLevel = { level: id, scenarios: [] };
        this.scenarios.push(currentLevel);
        nodeStack.length = 0;
      }
      else if (section === 'NAME') {
        const paramsObj = this.parseParams(params);
        currentScenario = {
          name: id,
          type: paramsObj.type || 'unknown',
          level: parseInt(paramsObj.level) || 1,
          probability: 0,
          rootNodes: []
        };
        currentLevel.scenarios.push(currentScenario);
        this.scenarioMap.set(paramsObj.type, currentScenario);
        nodeStack.length = 0;
      }
      else if (section === 'NODE') {
        const depth = this.getIndentDepth(line);
        const node = {
          id: id.trim(),
          depth,
          condition,
          probability: parseFloat(probability) || 1.0,
          phase,
          message,
          params: this.parseParams(params),
          children: []
        };

        if (condition === 'new_case') {
          currentScenario.probability = node.probability;
        }

        while (nodeStack.length > 0 && nodeStack[nodeStack.length - 1].depth >= depth) {
          nodeStack.pop();
        }

        if (nodeStack.length === 0) {
          currentScenario.rootNodes.push(node);
        } else {
          nodeStack[nodeStack.length - 1].children.push(node);
        }

        nodeStack.push(node);
      }
    }
  }
  
  parseCSVLine(line) {
    const regex = /(?:^|,)(\"(?:[^\"]+|\"\")*\"|[^,]*)/g;
    const result = [];
    let match;
    while (match = regex.exec(line)) {
      let value = match[1];
      if (value.startsWith('"') && value.endsWith('"')) {
        value = value.substring(1, value.length - 1).replace(/""/g, '"');
      }
      result.push(value.trim());
    }
    
    if (line.endsWith(',')) {
        result.push('');
    }

    while (result.length < 7) {
      result.push('');
    }

    return result;
  }

  getIndentDepth(line) {
    const match = line.match(/^(\s*)/);
    if (!match) return 0;
    return Math.floor(match[1].length / 2);
  }

  parseParams(paramsStr) {
    if (!paramsStr) return {};
    const pairs = paramsStr.split(';').filter(p => p.trim());
    const result = {};
    for (const pair of pairs) {
      const [key, value] = pair.split('=').map(s => s.trim());
      if (key && value) {
        result[key] = value;
      }
    }
    return result;
  }

  async loadFromFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          this.parseCSV(e.target.result);
          resolve();
        } catch (error) {
          reject(error);
        }
      };
      reader.onerror = reject;
      reader.readAsText(file);
    });
  }
}

// ==========================================
// メッセージパーサー
// ==========================================
// ==========================================
// メッセージパーサー
// ==========================================

class MessageParser {
  constructor(paramLists) {
    this.paramLists = paramLists;
  }

  parse(template, context) { // seed引数を削除
    let result = template;
    let lastResult = '';

    while (result !== lastResult) {
        lastResult = result;

        result = result.replace(/\{([^}#]+\/[^}]+)\}/g, (match, items) => {
          const choices = items.split('/').map(s => s.trim());
          const index = Math.floor(Math.random() * choices.length); // Math.random() に変更
          return choices[index];
        });

        result = result.replace(/\{#(\w+):(\d+)-(\d+)\}/g, (match, name, min, max) => {
          const minVal = parseInt(min);
          const maxVal = parseInt(max);
          return Math.floor(Math.random() * (maxVal - minVal + 1)) + minVal; // Math.random() に変更
        });

        result = result.replace(/\{#(\w+)\}/g, (match, name) => {
          if (name === 'num') {
            return Math.floor(Math.random() * 3) + 1; // Math.random() に変更
          }
          if (name === 'eta') {
            return Math.floor(Math.random() * 9) + 2; // Math.random() に変更
          }
          if (this.paramLists[name]) {
            const list = this.paramLists[name];
            const index = Math.floor(Math.random() * list.length); // Math.random() に変更
            return list[index];
          }
          return match;
        });

        result = result.replace(/\{(\w+)\}/g, (match, key) => {
          const value = context[key];
          return (value !== undefined && value !== null) ? value : '';
        });
    }

    result = result.replace(/\{([^{}]+)\}/g, (match, content) => content);
    result = result.replace(/、\s*、/g, '、').replace(/、$/g, '');

    return result;
  }

  // rand01メソッドは完全に削除
}

// ==========================================
// シナリオエンジン
// ==========================================
// ==========================================
// シナリオエンジン
// ==========================================

class ScenarioEngine {
  constructor(loader, unitTypes) { // seed引数を削除
    this.loader = loader;
    this.parser = new MessageParser(loader.paramLists);
    this.unitTypes = unitTypes;
    this.activeCases = new Map();
    this.caseIdCounter = 1;
  }

  evaluateCondition(condition, caseState) {
    if (!condition) return false;
    switch (condition) {
      case 'new_case': return caseState.isNew;
      case 'awaiting_response': return caseState.awaitingResponse;
      case 'default': return true;
      case 'has_units': return caseState.hasAvailableBackupUnits;
      default:
        if (condition.startsWith('rand<')) {
          const threshold = parseFloat(condition.substring(5));
          return Math.random() < threshold; // Math.random() に変更
        }
        return false;
    }
  }

  selectNextNode(currentNode, caseState) {
    const candidates = currentNode.children.filter(child => {
      const conditionMet = this.evaluateCondition(child.condition, caseState);
      const probabilityMet = Math.random() < child.probability; // Math.random() に変更
      return conditionMet && probabilityMet;
    });
    if (candidates.length === 0) {
      return currentNode.children.find(child => child.condition === 'default') || null;
    }
    return candidates[0];
  }

  // ▼▼▼【ここから置き換え】▼▼▼
  generateNewCase(busyUnits) {
    const allScenarios = this.loader.scenarios.flatMap(level => level.scenarios);
    const totalWeight = allScenarios.reduce((sum, s) => sum + s.probability, 0);
    if (totalWeight <= 0) return null;
    
    const r = Math.random() * totalWeight;
    let cumulative = 0;
    let selectedScenario = allScenarios[0];
    for (const scenario of allScenarios) {
      cumulative += scenario.probability;
      if (r <= cumulative) {
        selectedScenario = scenario;
        break;
      }
    }

    const scenarioType = selectedScenario.type;
    let unitTypeKey;
    if (['suspicious_object', 'demonstration'].includes(scenarioType)) {
        unitTypeKey = 'backup';
    } else if (['traffic_violation', 'parking_violation', 'traffic_accident', 'hit_and_run'].includes(scenarioType)) {
        unitTypeKey = 'traffic';
    } else if (['patrol', 'suspicious'].includes(scenarioType)) {
        unitTypeKey = 'patrol';
    } else {
        unitTypeKey = 'investigation';
    }
    
    const unitPool = this.unitTypes[unitTypeKey] || [];
    const availableUnitsForCase = unitPool.filter(u => !busyUnits.has(u));
    if (availableUnitsForCase.length === 0) return null;
    
    const unit = availableUnitsForCase[Math.floor(Math.random() * availableUnitsForCase.length)];
    const zoneList = this.loader.paramLists.zones || [];
    const zone = zoneList[Math.floor(Math.random() * zoneList.length)];
    const caseId = `C${String(this.caseIdCounter++).padStart(4, '0')}`;
    const firstNode = selectedScenario.rootNodes[0];
    
    const caseObj = {
      id: caseId, scenario: selectedScenario, currentNode: firstNode,
      zone, unit, backupUnits: [], level: selectedScenario.level,
      startTime: Date.now(), awaitingResponse: true, phase: firstNode.phase,
      isVisible: false
    };

    // ★★★ 最初のノードにレベル引き上げ指定があれば、この時点で適用する ★★★
    if (firstNode.params && firstNode.params.escalate_level) {
        const newLevel = parseInt(firstNode.params.escalate_level, 10);
        if (!isNaN(newLevel)) {
            caseObj.level = newLevel;
        }
    }

    if (firstNode.params && firstNode.params.add_units) {
        const newUnits = firstNode.params.add_units.split(';');
        newUnits.forEach(unitName => {
            if (!caseObj.backupUnits.includes(unitName)) {
                caseObj.backupUnits.push(unitName);
            }
        });
    }

    this.activeCases.set(caseId, caseObj);
    const context = { unit, zone, type_ja: selectedScenario.name };
    let message = this.parser.parse(firstNode.message, context);
    message = message.replace(/東京/g, locationName);
    
    return {
      id: `N${String(this.caseIdCounter++).padStart(6, '0')}`,
      caseId, 
      level: caseObj.level, // ★更新後の正しいレベルを渡す
      phase: firstNode.phase, zone, unit, message, scenarioName: selectedScenario.name,
      params: firstNode.params
    };
  }
// ▲▲▲【ここまで置き換え】▲▲▲

  // ▼▼▼【ここから置き換え】▼▼▼
  progressCase(caseId, busyUnits) {
    const caseObj = this.activeCases.get(caseId);
    if (!caseObj) return null;

    if (caseObj.isDeleting) {
      return null;
    }

    const availableBackupUnits = (this.unitTypes.backup || []).filter(u => !busyUnits.has(u));
    const caseState = {
      id: caseId, isNew: false, awaitingResponse: caseObj.awaitingResponse,
      elapsed: Math.floor((Date.now() - caseObj.startTime) / 1000),
      hasAvailableBackupUnits: availableBackupUnits.length > 0
    };

    const nextNode = this.selectNextNode(caseObj.currentNode, caseState);

    if (!nextNode) {
      if (caseObj.awaitingResponse) {
        caseObj.awaitingResponse = false;
      }
      return null;
    }

    caseObj.currentNode = nextNode;
    caseObj.phase = nextNode.phase;
    caseObj.awaitingResponse = (nextNode.condition === 'awaiting_response');

    // ★★★ レベル引き上げを、この時点で即時適用する ★★★
    if (nextNode.params && nextNode.params.escalate_level) {
        const newLevel = parseInt(nextNode.params.escalate_level, 10);
        if (!isNaN(newLevel)) {
            caseObj.level = newLevel;
        }
    }

    if (caseObj.phase === 'clear' && !caseObj.isDeleting) {
      caseObj.isDeleting = true;
      setTimeout(() => this.activeCases.delete(caseId), 5000);
    }

    if (nextNode.params && nextNode.params.add_units) {
        const newUnits = nextNode.params.add_units.split(';');
        newUnits.forEach(unitName => {
            if (!caseObj.backupUnits.includes(unitName) && caseObj.unit !== unitName) {
                caseObj.backupUnits.push(unitName);
            }
        });
    }

    let backupUnit = null;
    if (nextNode.phase === 'backup_response' && availableBackupUnits.length > 0) {
      backupUnit = availableBackupUnits[0];
      caseObj.backupUnits.push(backupUnit);
    }
    
    const latestBackupUnit = caseObj.backupUnits.length > 0 ? caseObj.backupUnits[caseObj.backupUnits.length - 1] : null;

    const context = {
      unit: caseObj.unit, zone: caseObj.zone, type_ja: caseObj.scenario.name,
      backup_unit: backupUnit || latestBackupUnit
    };
    
    let message = this.parser.parse(nextNode.message, context);
    message = message.replace(/東京/g, locationName);

    return {
      id: `N${String(this.caseIdCounter++).padStart(6, '0')}`,
      caseId, 
      level: caseObj.level, // ★更新後の正しいレベルを渡す
      phase: nextNode.phase, zone: caseObj.zone,
      unit: backupUnit || caseObj.unit, message, scenarioName: caseObj.scenario.name,
      params: nextNode.params
    };
  }
// ▲▲▲【ここまで置き換え】▲▲▲

  getAllActiveCases() {
    return Array.from(this.activeCases.values()).filter(c => c.phase !== 'clear');
  }
  
  getVisibleCases() {
      return this.getAllActiveCases().filter(c => c.isVisible);
  }
}
// ==========================================
// UI更新
// ==========================================
function updateCaseStatus() {
  const el = document.getElementById("caseList");
  if (!scenarioEngine) {
    el.innerHTML = '<div class="no-cases">CSVファイルを読み込んでください</div>';
    return;
  }
  
  const active = scenarioEngine.getVisibleCases();
  if (active.length === 0) {
    el.innerHTML = '<div class="no-cases">現在、進行中の事案はありません</div>';
    return;
  }

  active.sort((a, b) => b.level - a.level);
  el.innerHTML = active.map(c => {
    const t = Math.floor((Date.now() - c.startTime) / 1000);
    const m = Math.floor(t / 60), s = t % 60;
    const allUnits = [c.unit, ...c.backupUnits];
    const unitsStr = allUnits.slice(0, 2).join('・ ') + (allUnits.length > 2 ? ` 他${allUnits.length - 2}台` : '');
    const levelClass = `lv${c.level}`;
    const phaseMap = {
      dispatch: '出動指令', enroute: '現場向け', on_scene: '現場対応中',
      backup: '応援要請', backup_response: '応援出動', escalate: 'エスカレート',
      escape: '逃走追跡', arrest: '容疑者確保', negotiation: '交渉中',
      assault: '強行突入', special_request: '特殊部隊要請', clear: '処理完了'
    };
    return `<div class="case-card">
      <div class="case-header">
        <span class="level-badge ${levelClass}">LV${c.level}</span>
        <span class="case-id">${c.id}</span>
        <span class="case-type">${c.scenario.name}</span>
      </div>
      <div class="case-body">
        <div class="case-info-row"><span class="info-label">地区:</span><span class="info-value">${c.zone}</span></div>
        <div class="case-info-row"><span class="info-label">状態:</span><span class="info-value">${phaseMap[c.phase] || c.phase}</span></div>
      </div>
      <div class="case-footer">
        <span class="case-units">${unitsStr}</span>
        <span class="case-time">${m}:${String(s).padStart(2, '0')}</span>
      </div>
    </div>`;
  }).join('');
}

// ==========================================
// ユーティリティ
// ==========================================

const sleep = ms => new Promise(r => setTimeout(r, ms));

async function typeOut(seed, cpsBase, ev, msgEl) {
  const pauses = { ",": 120, "、": 160, ".": 180, "。": 220, " ": 50 };
  const base = 1000 / cpsBase;
  msgEl.textContent = "";

  for (let i = 0; i < ev.message.length; i++) {
    const ch = ev.message[i];
    let extra = pauses[ch] || 0;
    await sleep(base + extra);
    msgEl.textContent += ch;
  }
}

// ==========================================
// 時報音（音声ONの時のみ）
// ==========================================

function ensureAudio() {
  if (!audioCtx)
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === "suspended")
    audioCtx.resume();
}
function playChirp(type) {
  if (!audioCtx) return;
  const t0 = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'triangle'; // 'sine'から'square'に変更
  gain.gain.value = 0;

  if (type === 'start') {
    // ピコッ (上昇2音)
    osc.frequency.setValueAtTime(250, t0 + 0.12);
    gain.gain.linearRampToValueAtTime(0.05, t0 + 0.13); // ゲインを少し調整
    gain.gain.linearRampToValueAtTime(0, t0 + 0.17);

    osc.frequency.setValueAtTime(750, t0 + 0.06);
    gain.gain.linearRampToValueAtTime(0.05, t0 + 0.07); // ゲインを少し調整
    gain.gain.linearRampToValueAtTime(0, t0 + 0.11);
  } else if (type === 'end') {
    // ピロリッ (下降3音)
    osc.frequency.setValueAtTime(1500, t0);
    gain.gain.linearRampToValueAtTime(0.05, t0 + 0.01); // ゲインを少し調整
    gain.gain.linearRampToValueAtTime(0, t0 + 0.05);

    osc.frequency.setValueAtTime(750, t0 + 0.06);
    gain.gain.linearRampToValueAtTime(0.05, t0 + 0.07); // ゲインを少し調整
    gain.gain.linearRampToValueAtTime(0, t0 + 0.11);

    osc.frequency.setValueAtTime(250, t0 + 0.12);
    gain.gain.linearRampToValueAtTime(0.05, t0 + 0.13); // ゲインを少し調整
    gain.gain.linearRampToValueAtTime(0, t0 + 0.17);
  }

  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(t0);
  osc.stop(t0 + 0.2);
}

function startWhiteNoise() {
  if (!audioCtx) return;
  const bufferSize = audioCtx.sampleRate * 1;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const output = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    output[i] = Math.random() * 2 - 1;
  }

  whiteNoiseNode = audioCtx.createBufferSource();
  whiteNoiseNode.buffer = buffer;
  whiteNoiseNode.loop = true;
  
  const gainNode = audioCtx.createGain();
  
  // ▼▼▼【ここからが変更点】▼▼▼
  // ローパスフィルターを作成
  const filterNode = audioCtx.createBiquadFilter();
  filterNode.type = 'lowpass';
  filterNode.frequency.value = 3000; // この値を下げるとさらに重い音になる

  // 接続順を変更: source -> filter -> gain -> destination
  whiteNoiseNode.connect(filterNode);
  filterNode.connect(gainNode);
  // ▲▲▲【ここまでが変更点】▲▲▲

  gainNode.connect(audioCtx.destination);
  
  gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
  gainNode.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + 0.1);
  
  whiteNoiseNode.start();
}

function startWhiteNoise() {
  if (!audioCtx) return;
  const bufferSize = audioCtx.sampleRate * 1;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const output = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    output[i] = Math.random() * 2 - 1;
  }

  whiteNoiseNode = audioCtx.createBufferSource();
  whiteNoiseNode.buffer = buffer;
  whiteNoiseNode.loop = true;
  
  const gainNode = audioCtx.createGain();
  
  // ▼▼▼【ここからが変更点】▼▼▼
  // 既存のローパスフィルター
  const lowPassFilter = audioCtx.createBiquadFilter();
  lowPassFilter.type = 'lowpass';
  lowPassFilter.frequency.value = 1500;

  // 新しくハイパスフィルターを作成
  const highPassFilter = audioCtx.createBiquadFilter();
  highPassFilter.type = 'highpass';
  highPassFilter.frequency.value = 500; // 低音域をカット

  // 接続順を変更: source -> high-pass -> low-pass -> gain -> destination
  whiteNoiseNode.connect(highPassFilter);
  highPassFilter.connect(lowPassFilter);
  lowPassFilter.connect(gainNode);
  // ▲▲▲【ここまでが変更点】▲▲▲

  gainNode.connect(audioCtx.destination);
  
  gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
  // ▼▼▼【変更点】音量を25%に (0.2 * 0.25 = 0.05) ▼▼▼
  gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 1);
  
  whiteNoiseNode.start();
}

function stopWhiteNoise() {
  return new Promise(resolve => {
    if (!whiteNoiseNode || !whiteNoiseNode.buffer) {
      resolve();
      return;
    }
    const gainNode = audioCtx.createGain();
    gainNode.connect(audioCtx.destination);
    
    // ▼▼▼【変更点】音量を25%に (0.2 * 0.25 = 0.05) ▼▼▼
    gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
    gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05);

    try {
        whiteNoiseNode.disconnect();
        whiteNoiseNode.connect(gainNode);
    } catch (e) {
        // エラーは無視
    }

    setTimeout(() => {
      try {
        whiteNoiseNode.stop();
      } catch (e) {
        // エラーは無視
      }
      whiteNoiseNode = null;
      resolve();
    }, 50);
  });
}

function toneNTT(kind) {
  if (!TTS_ENABLED || !audioCtx) return;
  const p = {
    pip: { f: 2000, dur: 4, g: 0.03, atk: 0.001, dec: 0.030, rel: 0.030, h2: 0.3 },
    pop: { f: 500, dur: 100, g: 0.06, atk: 0.001, dec: 0.050, rel: 0.060, h2: 1 },
    peen: { f: 1000, dur: 600, g: 0.06, atk: 0.003, dec: 0.01, rel: 0.003, h2: 1 }
  }[kind];

  const ctx = audioCtx, t0 = ctx.currentTime;
  const osc = ctx.createOscillator(); osc.type = 'square'; osc.frequency.value = p.f;
  const gain = ctx.createGain(); gain.gain.value = 0;
  const filter = ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = p.f * 1.4;
  osc.connect(filter); filter.connect(gain); gain.connect(ctx.destination);

  const g = gain.gain;
  g.setValueAtTime(0, t0);
  g.linearRampToValueAtTime(p.g, t0 + p.atk);
  g.linearRampToValueAtTime(p.g * 0.8, t0 + p.atk + p.dec);
  g.linearRampToValueAtTime(0.0001, t0 + (p.dur / 1000) + p.rel);

  osc.start(t0);
  osc.stop(t0 + (p.dur / 1000) + p.rel + 0.05);
}

// ▼▼▼【ここからが追加箇所】▼▼▼

// ▼▼▼【ここから置き換え】▼▼▼
function playEmergencyBeep(durationMs) {
  if (!TTS_ENABLED || !audioCtx) return Promise.resolve();
  
  ensureAudio();
  
  return new Promise(resolve => {
    const t0 = audioCtx.currentTime;
    const durationSec = durationMs / 1000;

    // 2つの音をまとめるためのメインの音量コントローラー
    const mainGain = audioCtx.createGain();
    mainGain.connect(audioCtx.destination);
    mainGain.gain.value = 0;

    // --- 2つの発振器（オシレーター）を準備 ---
    const osc1 = audioCtx.createOscillator();
    const osc2 = audioCtx.createOscillator();

    // 波形を「ノコギリ波(sawtooth)」に。これが刺々しい音の元になります。
    osc1.type = 'sine';
    osc2.type = 'sine';

    // 周波数を少しだけズラすことで、うなるような不協和音を作ります。
    osc1.frequency.setValueAtTime(1000, t0); // 1000Hzの音
    osc2.frequency.setValueAtTime(1030, t0); // 少し高い1030Hzの音

    // 各オシレーターをメインの音量コントローラーに接続
    osc1.connect(mainGain);
    osc2.connect(mainGain);

    // --- 音量の制御 ---
    const attackTime = 0.005;
    const releaseTime = 0.01;
    // 音量を少しだけ上げる (0.1 -> 0.15)
    mainGain.gain.linearRampToValueAtTime(0.02, t0 + attackTime);
    mainGain.gain.setValueAtTime(0.02, t0 + durationSec - releaseTime);
    mainGain.gain.linearRampToValueAtTime(0, t0 + durationSec);

    // --- 再生と停止 ---
    osc1.start(t0);
    osc2.start(t0);
    osc1.stop(t0 + durationSec);
    osc2.stop(t0 + durationSec);

    // 最後のオシレーターが停止したタイミングで完了を通知
    osc2.onended = resolve;
  });
}
// ▲▲▲【ここまで置き換え】▲▲▲

function startTimeSignal() {
  if (tickTimer) clearTimeout(tickTimer); // clearIntervalから変更
  if (!TTS_ENABLED) return;
  
  ensureAudio();

  const tick = () => {
    // 待機中に音声がオフにされた場合、タイマーを停止
    if (!TTS_ENABLED) { 
      tickTimer = null;
      return;
    }

    const s = new Date().getSeconds();
    if (s % 10 === 0) { toneNTT('peen'); }
    else if (s >= 57) { toneNTT('pop'); }
    else { toneNTT('pip'); }
    
    // 次の秒の切り替わりまでの時間を計算して、次のタイマーをセット
    const delay = 1000 - new Date().getMilliseconds();
    tickTimer = setTimeout(tick, delay);
  };

  // 最初の1回は、次の秒の切り替わりジャストに実行するよう予約
  const firstDelay = 1000 - new Date().getMilliseconds();
  tickTimer = setTimeout(tick, firstDelay);
}

function stopTimeSignal() {
  if (tickTimer) {
    clearTimeout(tickTimer); // clearIntervalから変更
    tickTimer = null;
  }
}

// ==========================================
// 時計
// ==========================================

(function () {
  const el = document.getElementById("jst");
  function pad(n, len = 2) { return String(n).padStart(len, "0"); }
  function tick() {
    const now = new Date();
    const ms = String(now.getMilliseconds()).padStart(3, '0');
    el.textContent = `${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}.${ms}`;
  }
  tick();
  setInterval(tick, 50); // 更新間隔を短縮してミリ秒を表示
})();

// ==========================================
// 自動スクロール制御
// ==========================================

(function() {
  const log = document.getElementById("log");
  
  log.addEventListener('wheel', () => {
    userScrolling = true;
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => { userScrolling = false; }, 2000);
  });
  
  log.addEventListener('touchstart', () => { userScrolling = true; });
  
  log.addEventListener('touchend', () => {
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => { userScrolling = false; }, 2000);
  });
  
  log.addEventListener('mousedown', (e) => {
    if (e.offsetX > log.clientWidth) { userScrolling = true; }
  });
  
  log.addEventListener('mouseup', () => {
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => { userScrolling = false; }, 2000);
  });
})();

// ==========================================
// 音声（簡易版）
// ==========================================

function loadVoices() {
  if (!('speechSynthesis' in window)) return;
  const load = () => {
    const vs = speechSynthesis.getVoices();
    const sel = document.getElementById("voiceSel");
    sel.innerHTML = '<option value="">Auto Select</option>';
    vs.forEach((v, i) => {
      const o = document.createElement('option');
      o.value = String(i); o.textContent = `${v.name} (${v.lang})`;
      sel.appendChild(o);
    });
    const jaVoice = vs.find(v => /^ja/i.test(v.lang)) || vs[0];
    chosenVoice = jaVoice;
  };
  load();
  speechSynthesis.onvoiceschanged = load;
}
loadVoices();

document.getElementById("voiceSel").addEventListener('change', () => {
  const vs = speechSynthesis.getVoices();
  const i = parseInt(document.getElementById("voiceSel").value);
  chosenVoice = Number.isInteger(i) ? vs[i] : vs.find(v => /^ja/i.test(v.lang));
});

document.getElementById("rateSlider").addEventListener('input', (e) => {
  ttsRate = parseFloat(e.target.value);
  document.getElementById("rateValue").textContent = ttsRate.toFixed(1);
});

async function speakMessage(text) {
  if (!TTS_ENABLED || !('speechSynthesis' in window)) return;
  
  const utter = new SpeechSynthesisUtterance(text);
  utter.lang = chosenVoice?.lang || 'ja-JP';
  utter.voice = chosenVoice || null;
  utter.rate = ttsRate;
  utter.pitch = 1.0;
  utter.volume = 0.1;

  return new Promise((resolve) => {
    utter.onend = resolve;
    utter.onerror = resolve;
    try {
      if (speechSynthesis.speaking) speechSynthesis.cancel();
      speechSynthesis.speak(utter);
    } catch {
      resolve();
    }
  });
}

// ==========================================
// メインループ
// ==========================================

// ▼▼▼【ここから置き換え】▼▼▼
async function runSystem() {
  if (!scenarioEngine) {
    alert('CSVファイルを先に読み込んでください');
    return;
  }

  const status = document.getElementById("status");
  const log = document.getElementById("log");
  const my = ++runningToken;

  log.innerHTML = "";
  scenarioEngine.activeCases.clear();
  scenarioEngine.caseIdCounter = 1;
  status.textContent = "ACTIVE";

  let lastDiagnosisTime = Date.now();
  
  // --- イベント（無線通信）を1つずつ処理するためのヘルパー関数 ---
  async function processAndDisplayEvent(event) {
    if (!event) return;

    const caseObj = scenarioEngine.activeCases.get(event.caseId);
    if (caseObj && event.phase === 'dispatch' && !caseObj.isVisible) {
      caseObj.isVisible = true;
    }

    const row = document.createElement("div");
    row.className = "radio-message";
    const meta = document.createElement("div");
    meta.className = "radio-message-meta";
    const ts = document.createElement("div");
    ts.className = "msg-time";
    const ts_now = new Date();
    ts.textContent = ts_now.toLocaleTimeString("ja-JP", { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
    const ch = document.createElement("div");
    ch.className = `msg-level lv${event.level}`;
    ch.textContent = `LV${event.level}`;
    const caseTag = document.createElement("div");
    caseTag.className = "msg-case";
    caseTag.textContent = event.caseId;
    meta.append(ts, ch, caseTag);
    const msg = document.createElement("div");
    msg.className = "msg-content";
    row.append(meta, msg);
    log.appendChild(row);
    
    if (!userScrolling) {
      setTimeout(() => { log.scrollTop = log.scrollHeight; }, 50);
    }

    if (event.params && event.params.alert === 'beep' && TTS_ENABLED) {
        await playEmergencyBeep(3000);
        await sleep(500);
    }

    if (TTS_ENABLED) {
      ensureAudio();
      playChirp('start');
      startWhiteNoise();
    }

    if (TTS_ENABLED) {
      await Promise.all([
        typeOut("", BASE_CPS, event, msg),
        speakMessage(event.message)
      ]);
    } else {
      await typeOut("", BASE_CPS, event, msg);
    }
    
    if (TTS_ENABLED) {
      await stopWhiteNoise();
      playChirp('end');
    }
    
    updateCaseStatus();
    
    await sleep(1250);
  }


  // --- メインの動作ループ ---
  updateCaseStatus();
  while (my === runningToken) {
    let eventToProcess = null;

    const busyUnits = new Set();
    for (const caseObj of scenarioEngine.activeCases.values()) {
        busyUnits.add(caseObj.unit);
        busyUnits.add(...caseObj.backupUnits);
    }

    // 優先度1: 既存事案の進行を試みる
    const caseIds = Array.from(scenarioEngine.activeCases.keys());
    for (const caseId of caseIds) {
      eventToProcess = scenarioEngine.progressCase(caseId, busyUnits);
      if (eventToProcess) {
        break; // 進行できる事案が見つかったらループを抜ける
      }
    }

    // 優先度2: 進行中の事案がなければ、新規事案の発生を試みる
    if (!eventToProcess) {
      let activeCount = scenarioEngine.getVisibleCases().length;
      const now = Date.now();
      if (activeCount < 5 || now - lastDiagnosisTime > 60000) {
        if (activeCount === 0) lastDiagnosisTime = now;
        eventToProcess = scenarioEngine.generateNewCase(busyUnits);
      }
    }
    
    // 処理すべきイベントが見つかった場合、それを表示して待機
    if (eventToProcess) {
      await processAndDisplayEvent(eventToProcess);
    } else {
      // 何も起きなかった場合は、少し待機してUIを更新
      updateCaseStatus();
      await sleep(1000);
    }
  }
}
// ▲▲▲【ここまで置き換え】▲▲▲
// ==========================================
// イベントリスナー
// ==========================================

function initializeSystem(csvText) {
    scenarioLoader = new ScenarioLoader();
    scenarioLoader.parseCSV(csvText);

    const unitTypes = {
        investigation: scenarioLoader.paramLists.units_investigation || [],
        traffic: scenarioLoader.paramLists.units_traffic || [],
        patrol: scenarioLoader.paramLists.units_patrol || [],
        backup: scenarioLoader.paramLists.units_backup || []
    };

    scenarioEngine = new ScenarioEngine(scenarioLoader, unitTypes);
    
    document.getElementById("syncBtn").disabled = false;
    document.getElementById("caseList").innerHTML = '<div class="no-cases">✅ シナリオ読込完了。システムを起動してください</div>';
}

window.addEventListener('DOMContentLoaded', async () => {
  const locationInput = document.getElementById("locationInput");
  const systemTitle = document.getElementById("systemTitle");
  
  locationInput.addEventListener('input', (e) => {
    const newName = e.target.value.trim();
    locationName = newName || "本部";
    systemTitle.textContent = `${locationName}通信指令観測システム（CSV駆動版）`;
  });
  
  systemTitle.textContent = `${locationInput.value.trim()}通信指令観測システム（CSV駆動版）`;

  try {
    const response = await fetch('scenario.csv');
    if (response.ok) {
      const csvText = await response.text();
      initializeSystem(csvText);
    } else {
      document.getElementById("caseList").innerHTML = '<div class="no-cases">❌ scenario.csvの読込に失敗しました。</div>';
    }
  } catch (fetchError) {
    document.getElementById("caseList").innerHTML = '<div class="no-cases">❌ scenario.csvの読込に失敗しました。</div>';
  }

  document.getElementById("toggleControls").addEventListener("click", () => {
    const controlPanel = document.getElementById("controlPanel");
    controlPanel.classList.toggle("hidden");
  });
});

document.getElementById("syncBtn").addEventListener("click", () => {
  if (TTS_ENABLED) {
    startTimeSignal();
  }
  runSystem();
});

document.getElementById("ttsToggle").addEventListener("click", () => {
  TTS_ENABLED = !TTS_ENABLED;
  const btn = document.getElementById("ttsToggle");
  btn.textContent = `音声: ${TTS_ENABLED ? "ON" : "OFF"}`;
  btn.className = TTS_ENABLED ? "btn active" : "btn";
  
  if (TTS_ENABLED) {
    startTimeSignal();
  } else {
    stopTimeSignal();
  }
});

</script>
</body>
</html>