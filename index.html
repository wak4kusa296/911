<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>通信指令観測システム</title>
  <meta name="theme-color" content="#1a1a1a">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="指令システム">
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icon-192.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Barlow+Condensed:wght@600&family=Kosugi&family=M+PLUS+1p:wght@300;500;700&display=swap" rel="stylesheet">
  <style>
    @font-face {
      font-family: 'DSEG7';
      src: url('DSEG7ClassicMini-Bold.woff') format('woff');
    }

    :root {
      --bg-primary: #1a1a1a;
      --bg-secondary: #242424;
      --bg-tertiary: #2e2e2e;
      --border: #3a3a3a;
      --text-primary: #e0e0e0;
      --text-secondary: #a0a0a0;
      --text-muted: #707070;
      --accent-blue: #e0e0e0;
      --accent-cyan: #e0e0e0;
      --lv1: #4caf50;
      --lv2: #ff9800;
      --lv3: #f44336;
      --lv4: #9c27b0;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      overflow: hidden;
    }

    * {
      box-sizing: border-box
    }

    body {
      background: var(--bg-primary);
      color: var(--text-primary);
      font: 14px/1.6 'M PLUS 1p', sans-serif;
      display: grid;
      font-weight: 500;
      grid-template-rows: auto auto 1fr;
    }

    .system-header {
      background: var(--bg-secondary);
      border-bottom: 2px solid var(--border);
      padding: 16px 24px;
    }

    .header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px; /* ▼▼▼【変更】gapを少し狭く調整 ▼▼▼ */
      flex-wrap: wrap;
    }

    .system-title {
      font-size: 18px;
      font-weight: 500;
      color: var(--accent-cyan);
      letter-spacing: 1px;
      text-transform: uppercase;
      margin-right: auto; /* ▼▼▼【追加】タイトルを左寄せに保つ ▼▼▼ */
    }

    .system-clock {
      font-weight: 500;
      color: var(--accent-cyan);
      font-family: 'DSEG7', monospace;
      letter-spacing: 0.5px;
      width: 100%;
      font-size: 10cqw;
      text-align: center;
    }

    .system-status {
      display: none;
    }

    .control-panel {
      width: 100%;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      padding: 12px 24px;
      transition: all 0.3s ease-in-out;
      overflow: hidden; /* ▼▼▼【追加】高さアニメーションのため ▼▼▼ */
    }

    /* ▼▼▼【変更】クラス名を is-open に変更し、非表示状態をデフォルトに ▼▼▼ */
    .control-panel:not(.is-open) {
      height: 0;
      padding-top: 0;
      padding-bottom: 0;
      border: none;
    }

    .control-row {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      width: 100%;
    }

    .btn {
      padding: 8px 20px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font: 12px/1.4 'Kosugi', 'M PLUS 1p', sans-serif;
      font-weight: 300;
      cursor: pointer;
      transition: all 0.2s;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      white-space: nowrap; /* ▼▼▼【追加】ボタンテキストの改行を防ぐ ▼▼▼ */
    }

    .btn:hover {
      background: var(--bg-primary);
      border-color: var(--accent-blue);
      color: var(--accent-blue);
    }

    .btn.primary {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: #000;
      font-weight: 500;
    }

    .btn.active {
      background: var(--accent-cyan);
      border-color: var(--accent-cyan);
      color: #000;
      font-weight: 500;
    }

    #closeControlsBtn {
      display: none;
    }

    .commander-input {
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font: 12px/1.4 'Kosugi', 'M PLUS 1p', sans-serif;
      min-width: 160px;
      height: 34px;
      flex-grow: 5;
    }

    .commander-input:focus {
      outline: none;
      border-color: var(--accent-blue);
    }

    .setting-lavel{
      width: 100%;
    }

    select {
      padding: 8px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font: 12px/1.4 'Kosugi', 'M PLUS 1p', sans-serif;
      cursor: pointer;
      min-width: 200px;
      width: 100%;
    }

    .rate-slider.disabled,
    select.disabled {
      opacity: 0.4;
      pointer-events: none;
      cursor: not-allowed;
    }

    .main-content {
      display: grid;
      grid-template-columns: 400px 1fr;
      gap: 0;
      overflow: hidden;
      height: 100%;
    }

    .case-panel {
      background: var(--bg-secondary);
      border-right: 2px solid var(--border);
      display: flex;
      flex-direction: column;
      min-height: 0;
      height: 100%;
    }

    .panel-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      background: var(--bg-tertiary);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .panel-title {
      font-size: 13px;
      font-weight: 500;
      color: var(--accent-cyan);
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    .rate-slider {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      flex-grow: 1;
      flex-wrap: wrap;
    }

    .rate-slider label {
      font-size: 11px;
      color: var(--text-muted);
      letter-spacing: 0.5px;
    }

    .rate-slider input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100px;
      height: 4px;
      background: var(--border);
      outline: none;
      border-radius: 2px;
      flex-grow: 1;
    }

    .rate-slider input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: var(--accent-blue);
      border-radius: 50%;
      cursor: pointer;
    }

    .rate-slider .value {
      font-weight: 500;
      color: var(--accent-blue);
      min-width: 35px;
      text-align: right;
    }
    .case-list { flex: 1; overflow-y: auto; overflow-x: hidden; padding: 20px; }
    .case-card { border-bottom: 1px solid var(--border); transition: background 0.2s; padding-bottom: 10px; margin-bottom: 20px; }
    .case-header { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; }
    .level-badge { padding: 4px 10px; border-radius: 3px; font-size: 11px; font-weight: 500; letter-spacing: 0.5px; }
    .level-badge.lv1 { background: var(--lv1); color: #000; }
    .level-badge.lv2 { background: var(--lv2); color: #000; }
    .level-badge.lv3 { background: var(--lv3); color: #fff; }
    .level-badge.lv4 { background: var(--lv4); color: #fff; }
    .case-id { font-size: 13px; font-weight: 500; color: var(--accent-blue); }
    .case-type { font-size: 12px; color: var(--text-primary); margin-left: auto; }
    .case-body { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px; color: var(--text-secondary); }
    .case-info-row { display: flex; gap: 6px; }
    .info-label { color: var(--text-muted); }
    .info-value { color: var(--text-secondary); font-weight: 300; }
    .case-footer { margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; font-size: 11px; }
    .case-units { color: var(--accent-cyan); font-weight: 300; }
    .case-time { color: var(--text-muted); font-family: 'DSEG7', sans-serif; }
    .msg-time { color: var(--text-muted); font-family: 'DSEG7', sans-serif; }
    .radio-panel { background: var(--bg-primary); display: flex; flex-direction: column; min-height: 0; }
    .radio-log { flex: 1; overflow-y: auto; overflow-x: hidden; padding: 12px; padding-bottom: 40px; }
    .radio-message { display: flex; flex-direction: column; gap: 6px; padding: 12px 16px; margin-bottom: 8px; background: var(--bg-secondary); border-left: 3px solid transparent; border-radius: 4px; transition: all 0.2s; opacity: 0; transform: translateY(10px); animation: slideIn 0.3s ease-out forwards; }
    .radio-message.alert { background: repeating-linear-gradient( -45deg, rgba(33, 33, 33, 0.6), rgba(33, 33, 33, 0.6) 12px, var(--bg-secondary) 12px, var(--bg-secondary) 24px ); border-left-color: #ff3b3b; border-left-width: 4px; }
    .radio-message.alert .msg-content { text-shadow: 1px 1px 3px rgba(0,0,0,0.7); }
    @keyframes slideIn { to { opacity: 1; transform: translateY(0); } }
    .radio-message-meta { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    .msg-level { padding: 4px 8px; border-radius: 3px; font-size: 11px; font-weight: 500; text-align: center; letter-spacing: 0.5px; color: var(--text-muted); }
    .msg-case { font-size: 11px; font-weight: 500; color: var(--text-muted); }
    .msg-content { font: 13px/1.7 'Kosugi', 'M PLUS 1p', sans-serif; font-weight: 500; color: var(--text-primary); word-break: break-word; padding-top: 4px; }
    .no-cases { padding: 40px 20px; text-align: center; color: var(--text-muted); font-size: 12px; }
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: var(--bg-primary); }
    ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

    @media (max-width: 768px) {
      .main-content {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
      }

      .case-panel {
        border-right: none;
        border-bottom: 2px solid var(--border);
        max-height: 25dvh;
      }
      .system-title {
        width: 100%;
        font-size: 6cqw;
        text-align: center;
      }

      /* ▼▼▼【ここからモバイル用のオーバーレイスタイル】▼▼▼ */
      
      /* ▼▼▼ メディアクエリ内に追加 ▼▼▼ */
      #closeControlsBtn {
        display: block;
        width: 100%;
        margin-top: 24px;
        border-color: var(--text-muted);
      }
      
      .rate-slider .value {
        width: 100%;
     }

      .control-panel {
        /* オーバーレイの基本設定 */
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(26, 26, 26, 0.95);
        backdrop-filter: blur(4px);
        /* 警報オーバーレイより手前に表示 */
        z-index: 10000; 
        
        /* ▼▼▼【変更】スクロール可能にしつつ中央揃えを維持 ▼▼▼ */
        display: flex;
        align-items: flex-start; /* centerからflex-startに変更 */
        justify-content: center;
        padding: 24px;
        overflow-y: auto;
        overflow-x: hidden;
        /* ▲▲▲【変更】ここまで ▲▲▲ */

        /* 表示/非表示のアニメーション設定 */
        opacity: 0;
        transform: scale(1.05);
        pointer-events: none;
        transition: opacity 0.2s ease-out, transform 0.2s ease-out;
      }
            
      /* is-openクラスが付いた時に表示する */
      .control-panel.is-open {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
      }

      .control-row {
        flex-direction: column;
        align-items: stretch;
        max-width: 400px; /* オーバーレイ内での最大幅 */
      }

      .commander-input,
      select,
      .rate-slider {
        min-width: 0;
        width: 100%;
      }
      
      .btn {
        width: 100%;
      }
      /* ▲▲▲【ここまで】▲▲▲ */
    }

    /* --- Emergency Overlay Styles (変更なし) --- */
    #emergency-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 9999; text-align: center; opacity: 0; pointer-events: none; transition: opacity 0.1s ease-in-out; backdrop-filter: blur(5px); }
    #emergency-overlay.active { opacity: 1; pointer-events: auto; }
    .emergency-text-wrapper { max-width: 95%; animation: sawtooth-fade 0.5s linear infinite; }
    .emergency-title { background-color: #ff3b3b; color: #1a1a1a; font-family: 'Barlow Condensed', sans-serif; font-weight: 600; font-size: clamp(16px, 3.5vw, 2rem); letter-spacing: 0.05em; text-transform: uppercase; padding: 0.6rem 1.5rem; margin-bottom: 1rem; white-space: nowrap; }
    .emergency-subtitle { color: #ff3b3b; text-shadow: 0 0 8px rgba(255, 59, 59, 0.8); font-size: clamp(14px, 2.5vw, 1.2rem); font-weight: 500; letter-spacing: 0.2em; white-space: nowrap; }
    .stripe-band { position: fixed; left: 0; width: 100%; height: 40px; background-image: repeating-linear-gradient( -45deg, #ff3b3b, #ff3b3b 15px, transparent 15px, transparent 30px ); background-size: 42.4264px 42.4264px; box-shadow: 0 0 15px rgba(0, 0, 0, 0.5); animation: scroll-stripe 0.7s linear infinite; }
    .stripe-band.top { top: 0; }
    .stripe-band.bottom { bottom: 0; }
    @keyframes scroll-stripe { from { background-position-x: 0; } to { background-position-x: -42.4264px; } }
  </style>
</head>

<body>
  <div id="emergency-overlay">
    <div class="stripe-band top"></div>
    <div class="emergency-text-wrapper">
      <div class="emergency-title">Automatic Calling System</div>
      <div class="emergency-subtitle">注意喚起音</div>
    </div>
    <div class="stripe-band bottom"></div>
  </div>

  <div class="system-header">
    <div class="header-row">
      <div class="system-title" id="systemTitle">通信指令観測システム</div>
      <div class="system-status" id="status">STANDBY</div>
      
      <button id="toggleControls" class="btn">設定</button>
      <button id="ttsToggle" class="btn">音声: OFF</button>
      <button id="syncBtn" class="btn primary" disabled>システム起動</button>
      
      <div class="system-clock" id="jst">--:--:--.-- JST</div>
    </div>
  </div>

  <div class="control-panel" id="controlPanel">
    <div class="control-row">
      <label class="setting-lavel">本部の名称</label>
      <input type="text" id="commanderInput" class="commander-input" value="本部">
      <label class="setting-lavel">音声設定（音声ONの時のみ編集可能）</label>
      <button id="ttsToggle2" class="btn">音声: OFF</button>
      <select id="voiceSel">
        <option value="">音声自動選択</option>
      </select>
      <div class="rate-slider">
        <label>速度:</label>
        <input type="range" id="rateSlider" min="0.5" max="3.0" step="0.1" value="1.5">
        <span class="value" id="rateValue">1.5</span>
      </div>
      <div class="rate-slider">
        <label>全体音量:</label>
        <input type="range" id="masterVolumeSlider" min="0" max="2" step="0.05" value="1.0">
        <span class="value" id="masterVolumeValue">1.00</span>
      </div>
      <div class="rate-slider">
        <label>ボイス音量:</label>
        <input type="range" id="ttsVolumeSlider" min="0" max="1" step="0.05" value="1.0">
        <span class="value" id="ttsVolumeValue">1.00</span>
      </div>
      <div class="rate-slider">
        <label>効果音音量:</label>
        <input type="range" id="sfxVolumeSlider" min="0" max="1" step="0.05" value="1.0">
        <span class="value" id="sfxVolumeValue">1.00</span>
      </div>
      <div class="rate-slider">
        <label>無線ノイズ音量:</label>
        <input type="range" id="noiseVolumeSlider" min="0" max="1" step="0.05" value="0.5">
        <span class="value" id="noiseVolumeValue">0.50</span>
      </div>
      <button id="closeControlsBtn" class="btn">閉じる</button>
    </div>
  </div>

  <div class="main-content">
    <div class="case-panel">
      <div class="panel-header">
        <div class="panel-title">進行中の事案</div>
      </div>
      <div class="case-list" id="caseList">
        <div class="no-cases">CSVファイルを読み込んでください</div>
      </div>
    </div>

    <div class="radio-panel">
      <div class="radio-log" id="log"></div>
    </div>
  </div>
<script>
// グローバル変数
const BASE_CPS = 12;
let commanderName = "本部";
let whiteNoiseNode = null;
let TTS_ENABLED = false;
let chosenVoice = null;
let ttsRate = 1.5;
let audioCtx = null;
// ▼▼▼【変更点】音量ミキサー（GainNode）をグローバルに定義 ▼▼▼
let masterGain = null;
let sfxGain = null;
let noiseGain = null;
// ▲▲▲【変更点】▲▲▲
let scenarioLoader = null;
let scenarioEngine = null;
let runningToken = 0;
let tickTimer = null;
let userScrolling = false;
let scrollTimeout = null;
let ttsVolume = 1.0; // TTS音量だけは別で保持

// ==========================================
// シナリオCSVローダー
// ==========================================

class ScenarioLoader {
  constructor() {
    this.paramLists = {};
    this.scenarios = [];
    this.scenarioMap = new Map();
  }

  parseCSV(csvText) {
    const lines = csvText.split('\n').filter(line => {
      const trimmed = line.trim();
      return trimmed && !trimmed.startsWith('#');
    });

    let currentLevel = null;
    let currentScenario = null;
    const nodeStack = [];

    for (let i = 1; i < lines.length; i++) {
      const line = lines[i];
      const [section, id, condition, probability, phase, message, params] = 
        this.parseCSVLine(line);

      if (section === 'PARAM') {
        this.paramLists[id] = params ? params.split(';').map(s => s.trim()) : [];
      } 
      else if (section === 'LEVEL') {
        currentLevel = { level: id, scenarios: [] };
        this.scenarios.push(currentLevel);
        nodeStack.length = 0;
      }
      else if (section === 'NAME') {
        const paramsObj = this.parseParams(params);
        currentScenario = {
          name: id,
          type: paramsObj.type || 'unknown',
          level: parseInt(paramsObj.level) || 1,
          probability: 0,
          rootNodes: []
        };
        currentLevel.scenarios.push(currentScenario);
        this.scenarioMap.set(paramsObj.type, currentScenario);
        nodeStack.length = 0;
      }
      else if (section === 'NODE') {
        const depth = this.getIndentDepth(line);
        const node = {
          id: id.trim(),
          depth,
          condition,
          probability: parseFloat(probability) || 1.0,
          phase,
          message,
          params: this.parseParams(params),
          children: []
        };

        if (condition === 'new_case') {
          currentScenario.probability = node.probability;
        }

        while (nodeStack.length > 0 && nodeStack[nodeStack.length - 1].depth >= depth) {
          nodeStack.pop();
        }

        if (nodeStack.length === 0) {
          currentScenario.rootNodes.push(node);
        } else {
          nodeStack[nodeStack.length - 1].children.push(node);
        }

        nodeStack.push(node);
      }
    }
  }
  
  parseCSVLine(line) {
    const regex = /(?:^|,)(\"(?:[^\"]+|\"\")*\"|[^,]*)/g;
    const result = [];
    let match;
    while (match = regex.exec(line)) {
      let value = match[1];
      if (value.startsWith('"') && value.endsWith('"')) {
        value = value.substring(1, value.length - 1).replace(/""/g, '"');
      }
      result.push(value.trim());
    }
    
    if (line.endsWith(',')) {
        result.push('');
    }

    while (result.length < 7) {
      result.push('');
    }

    return result;
  }

  getIndentDepth(line) {
    const match = line.match(/^(\s*)/);
    if (!match) return 0;
    return Math.floor(match[1].length / 2);
  }

  parseParams(paramsStr) {
    if (!paramsStr) return {};
    const pairs = paramsStr.split(';').filter(p => p.trim());
    const result = {};
    for (const pair of pairs) {
      const [key, value] = pair.split('=').map(s => s.trim());
      if (key && value) {
        result[key] = value;
      }
    }
    return result;
  }

  async loadFromFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          this.parseCSV(e.target.result);
          resolve();
        } catch (error) {
          reject(error);
        }
      };
      reader.onerror = reject;
      reader.readAsText(file);
    });
  }
}

// ==========================================
// メッセージパーサー
// ==========================================
class MessageParser {
  constructor(paramLists) {
    this.paramLists = paramLists;
  }

  parse(template, context) {
    let result = template;
    let lastResult = '';

    while (result !== lastResult) {
        lastResult = result;

        result = result.replace(/\{([^}#]+\/[^}]+)\}/g, (match, items) => {
          const choices = items.split('/').map(s => s.trim());
          const index = Math.floor(Math.random() * choices.length);
          return choices[index];
        });

        result = result.replace(/\{#(\w+):(\d+)-(\d+)\}/g, (match, name, min, max) => {
          const minVal = parseInt(min);
          const maxVal = parseInt(max);
          return Math.floor(Math.random() * (maxVal - minVal + 1)) + minVal;
        });

        result = result.replace(/\{#(\w+)\}/g, (match, name) => {
          if (name === 'num') {
            return Math.floor(Math.random() * 3) + 1;
          }
          if (name === 'eta') {
            return Math.floor(Math.random() * 9) + 2;
          }
          if (this.paramLists[name]) {
            const list = this.paramLists[name];
            const index = Math.floor(Math.random() * list.length);
            return list[index];
          }
          return match;
        });

        result = result.replace(/\{(\w+)\}/g, (match, key) => {
          const value = context[key];
          return (value !== undefined && value !== null) ? value : '';
        });
    }

    result = result.replace(/\{([^{}]+)\}/g, (match, content) => content);
    result = result.replace(/、\s*、/g, '、').replace(/、$/g, '');

    return result;
  }
}


// ==========================================
// シナリオエンジン
// ==========================================
class ScenarioEngine {
  constructor(loader, unitTypes) {
    this.loader = loader;
    this.parser = new MessageParser(loader.paramLists);
    this.unitTypes = unitTypes;
    this.activeCases = new Map();
    this.caseIdCounter = 1;
    this.nodeIdCounter = 1;
    // backup-all機能用のプロパティ
    this.isBackupAllActive = false;
    this.backupAllCaseId = null;
  }

  evaluateCondition(condition, caseState) {
    if (!condition) return false;
    switch (condition) {
      case 'new_case': return caseState.isNew;
      case 'awaiting_response': return caseState.awaitingResponse;
      case 'default': return true;
      case 'has_units': return caseState.hasAvailableBackupUnits;
      default:
        if (condition.startsWith('rand<')) {
          const threshold = parseFloat(condition.substring(5));
          return Math.random() < threshold;
        }
        return false;
    }
  }

  selectNextNode(currentNode, caseState) {
    const candidates = currentNode.children.filter(child => {
      const conditionMet = this.evaluateCondition(child.condition, caseState);
      const probabilityMet = Math.random() < child.probability;
      return conditionMet && probabilityMet;
    });
    if (candidates.length === 0) {
      return currentNode.children.find(child => child.condition === 'default') || null;
    }
    return candidates[0];
  }

generateNewCase(busyUnits) {
  // backup-all発令中は新規事件を生成しない
  if (this.isBackupAllActive) {
      return null;
  }

  const allScenarios = this.loader.scenarios.flatMap(level => level.scenarios);
  const totalWeight = allScenarios.reduce((sum, s) => sum + s.probability, 0);
  if (totalWeight <= 0) return null;

  // シナリオを確率に基づいて選択
  let selectedScenario = null;
  const r = Math.random() * totalWeight;
  let cumulative = 0;
  for (const scenario of allScenarios) {
      cumulative += scenario.probability;
      if (r <= cumulative) {
          selectedScenario = scenario;
          break;
      }
  }
  if (!selectedScenario) return null;

  const firstNode = selectedScenario.rootNodes[0];
  const isTriggeringBackupAll = firstNode.params && firstNode.params['backup-all'] === 'true';
  const availableBackupUnits = (this.unitTypes.backup || []).filter(u => !busyUnits.has(u));
  
  let unit;
  let backupUnitsForCase = [];

  // --- backup-allと通常事案の分岐処理 ---
  if (isTriggeringBackupAll) {
      // --- backup-allのロジック ---
      if (availableBackupUnits.length === 0) {
          return null;
      }
      
      // ★★★ 全ての利用可能なbackup_unitを割り当てる ★★★
      const primaryUnitIndex = Math.floor(Math.random() * availableBackupUnits.length);
      unit = availableBackupUnits[primaryUnitIndex];
      backupUnitsForCase = availableBackupUnits.filter((_, index) => index !== primaryUnitIndex);

      // グローバルなbackup-all状態を設定
      this.isBackupAllActive = true;
      this.backupAllCaseId = `C${String(this.caseIdCounter).padStart(4, '0')}`;

  } else {
      // --- 通常事案のロジック ---
      const scenarioType = selectedScenario.type;
      let unitTypeKey;
      
      if (['suspicious_object', 'demonstration'].includes(scenarioType)) {
          unitTypeKey = 'backup';
      } else if (['traffic_violation', 'parking_violation', 'traffic_accident', 'hit_and_run'].includes(scenarioType)) {
          unitTypeKey = 'traffic';
      } else if (['patrol', 'suspicious'].includes(scenarioType)) {
          unitTypeKey = 'patrol';
      } else {
          unitTypeKey = 'investigation';
      }
      
      const unitPool = this.unitTypes[unitTypeKey] || [];
      const availableUnitsForCase = unitPool.filter(u => !busyUnits.has(u));
      
      // backup_unitを必要とする事案の場合、待機ロジック
      if (unitTypeKey === 'backup') {
          const backupUnitsBusy = Array.from(busyUnits).some(u => 
              (this.unitTypes.backup || []).includes(u)
          );
          
          if (backupUnitsBusy) {
              return null; // 待機
          }
      }
      
      if (availableUnitsForCase.length === 0) {
          return null;
      }
      unit = availableUnitsForCase[Math.floor(Math.random() * availableUnitsForCase.length)];
  }

  // --- 全ての事案に共通のロジック ---
  const caseId = `C${String(this.caseIdCounter++).padStart(4, '0')}`;
  if (isTriggeringBackupAll) {
      this.backupAllCaseId = caseId;
  }
  const zoneList = this.loader.paramLists.zones || [];
  const zone = zoneList[Math.floor(Math.random() * zoneList.length)];
  
  const caseObj = {
    id: caseId, scenario: selectedScenario, currentNode: firstNode,
    zone, unit, backupUnits: backupUnitsForCase, level: selectedScenario.level,
    startTime: Date.now(), awaitingResponse: true, phase: firstNode.phase,
    isVisible: false
  };

  if (firstNode.params && firstNode.params.add_units) {
      const newUnits = new Set(caseObj.backupUnits);
      firstNode.params.add_units.split(';').forEach(unitName => newUnits.add(unitName));
      caseObj.backupUnits = Array.from(newUnits);
  }
  
  caseObj.backupUnits = caseObj.backupUnits.filter(bu => bu !== caseObj.unit);

  if (firstNode.params && firstNode.params.escalate_level) {
      const newLevel = parseInt(firstNode.params.escalate_level, 10);
      if (!isNaN(newLevel)) {
          caseObj.level = newLevel;
      }
  }

  this.activeCases.set(caseId, caseObj);
  const context = { unit, zone, type_ja: selectedScenario.name, commander: commanderName };
  let message = this.parser.parse(firstNode.message, context);
  
  return {
    id: `N${String(this.nodeIdCounter++).padStart(6, '0')}`,
    caseId, 
    level: caseObj.level,
    phase: firstNode.phase, zone, unit, message, scenarioName: selectedScenario.name,
    params: firstNode.params
  };
}


// ==========================================
// 4. progressCase関数（完全版）
// index.html の 862-940行目を以下に置き換え
// ==========================================

progressCase(caseId, busyUnits) {
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
    console.log('🔵 progressCase: 開始');
    console.log('  事案ID:', caseId);
    console.log('  isBackupAllActive:', this.isBackupAllActive);
    console.log('  backupAllCaseId:', this.backupAllCaseId);
    
    const caseObj = this.activeCases.get(caseId);
    if (!caseObj) {
      console.log('  ❌ 事案が見つかりません');
      return null;
    }

    console.log('  📋 現在のフェーズ:', caseObj.phase);
    console.log('  📋 現在のユニット:', caseObj.unit);
    console.log('  📋 現在のバックアップ:', caseObj.backupUnits);

    // 利用可能なbackup_unitを取得
    const allBackupUnits = this.unitTypes.backup || [];
    console.log('  📊 全backup_unit:', allBackupUnits);
    console.log('  📊 busyUnits:', Array.from(busyUnits));
    
    const availableBackupUnits = allBackupUnits.filter(u => !busyUnits.has(u));
    console.log('  ✅ 利用可能なbackup_unit:', availableBackupUnits);
    console.log('  📈 利用可能数:', availableBackupUnits.length);
    
    const caseState = {
      id: caseId,
      isNew: false,
      awaitingResponse: caseObj.awaitingResponse,
      elapsed: Math.floor((Date.now() - caseObj.startTime) / 1000),
      hasAvailableBackupUnits: availableBackupUnits.length > 0
    };

    const nextNode = this.selectNextNode(caseObj.currentNode, caseState);
    if (!nextNode) {
      console.log('  ⏭️  次のノードがありません');
      if (caseObj.awaitingResponse) caseObj.awaitingResponse = false;
      return null;
    }

    console.log('  ✅ 次のノード:', nextNode.phase);
    console.log('  📋 nextNode.condition:', nextNode.condition);
    console.log('  📋 nextNode.message:', nextNode.message.substring(0, 50) + '...');
    console.log('  📋 nextNode.params:', nextNode.params);

    // --- backup-all発令中の他事案待機ロジック ---
    // backup-all発令事案自体は進める
    // backupユニットを必要としないノードも進める
    // backupユニットを必要とする他の事案のみ待機
    const needsBackup = nextNode.condition === 'has_units' || 
                        nextNode.message.includes('{backup_unit}');
    
    console.log('  🔍 needsBackup:', needsBackup);
    console.log('    - condition === has_units:', nextNode.condition === 'has_units');
    console.log('    - message includes {backup_unit}:', nextNode.message.includes('{backup_unit}'));
    
    if (this.isBackupAllActive && this.backupAllCaseId !== caseId && needsBackup) {
      console.log('  ⏸️  backup-all発令中のため、この事案は待機します');
      console.log('  ⏸️  backup-all事案:', this.backupAllCaseId);
      console.log('  ⏸️  この事案:', caseId);
      return null;
    }

    // --- backup-all発令ロジック ---
    const isTriggeringBackupAll = nextNode.params && nextNode.params['backup-all'] === 'true';
    console.log('  🚨 isTriggeringBackupAll:', isTriggeringBackupAll);
    
    if (isTriggeringBackupAll && !this.isBackupAllActive) {
      console.log('  ━━━━━━━━━━━━━━━━━━━━━━');
      console.log('  🔴 backup-all発令！');
      console.log('  ━━━━━━━━━━━━━━━━━━━━━━');
      
      this.isBackupAllActive = true;
      this.backupAllCaseId = caseId;
      
      console.log('  🔴 isBackupAllActive = true');
      console.log('  🔴 backupAllCaseId =', caseId);
      
      if (availableBackupUnits.length > 0) {
        const beforeBackups = [...caseObj.backupUnits];
        console.log('  📊 発令前のバックアップ:', beforeBackups);
        
        // 既存のバックアップユニットと重複しないように追加
        const existingBackups = new Set(caseObj.backupUnits);
        availableBackupUnits.forEach(unit => {
          if (!existingBackups.has(unit) && unit !== caseObj.unit) {
            existingBackups.add(unit);
            console.log('    ➕ 追加:', unit);
          }
        });
        caseObj.backupUnits = Array.from(existingBackups);
        
        console.log('  ✅ 発令後のバックアップ:', caseObj.backupUnits);
        console.log('  📈 追加された台数:', caseObj.backupUnits.length - beforeBackups.length);
        console.log('  📊 合計ユニット数:', 1 + caseObj.backupUnits.length);
      } else {
        console.log('  ⚠️  利用可能なbackup_unitがありませんでした');
      }
    }

    // --- ここから下は通常の進行ロジック ---

    caseObj.currentNode = nextNode;
    caseObj.phase = nextNode.phase;

    // エスカレーションレベルの処理
    if (nextNode.params && nextNode.params.escalate_level) {
      const newLevel = parseInt(nextNode.params.escalate_level, 10);
      if (!isNaN(newLevel)) {
        caseObj.level = newLevel;
        console.log('  ⬆️  レベルエスカレート:', newLevel);
      }
    }

    // add_unitsパラメータの処理
    if (nextNode.params && nextNode.params.add_units) {
      const beforeAdd = [...caseObj.backupUnits];
      const newUnits = new Set(caseObj.backupUnits);
      nextNode.params.add_units.split(';').forEach(unitName => newUnits.add(unitName));
      caseObj.backupUnits = Array.from(newUnits);
      console.log('  ➕ add_units処理');
      console.log('    - 処理前:', beforeAdd);
      console.log('    - 処理後:', caseObj.backupUnits);
    }

    // need-responseパラメータの処理
    if (nextNode.params && nextNode.params['need-response'] === 'true') {
      caseObj.awaitingResponse = true;
      console.log('  ⏸️  応答待機状態に設定');
    } else {
      caseObj.awaitingResponse = false;
    }

    // メッセージのパース
    const context = {
      unit: caseObj.unit,
      zone: caseObj.zone,
      type_ja: caseObj.scenario.name,
      commander: commanderName
    };

    if (caseObj.backupUnits && caseObj.backupUnits.length > 0) {
      context.backup_unit = caseObj.backupUnits[0];
      console.log('  📋 backup_unit context:', context.backup_unit);
    }

    let message = this.parser.parse(nextNode.message, context);

    console.log('  ━━━━━━━━━━━━━━━━━━━━━━');
    console.log('  ✅ 事案進行完了');
    console.log('  📋 事案ID:', caseId);
    console.log('  📋 フェーズ:', nextNode.phase);
    console.log('  📋 プライマリユニット:', caseObj.unit);
    console.log('  📋 バックアップユニット:', caseObj.backupUnits);
    console.log('  📋 合計ユニット数:', 1 + caseObj.backupUnits.length);
    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━');

    return {
      id: `N${String(this.nodeIdCounter++).padStart(6, '0')}`,
      caseId,
      level: caseObj.level,
      phase: nextNode.phase,
      zone: caseObj.zone,
      unit: caseObj.unit,
      message,
      scenarioName: caseObj.scenario.name,
      params: nextNode.params
    };
  }
  
  getAllActiveCases() {
    return Array.from(this.activeCases.values()).filter(c => c.phase !== 'clear');
  }
  
  getVisibleCases() {
      return this.getAllActiveCases().filter(c => c.isVisible);
  }
}

// ==========================================
// UI更新
// ==========================================

// ▼▼▼【ここから追加】▼▼▼
function updateTimers() {
  const now = Date.now();
  // data-start-time 属性を持つすべての事案カードを取得
  document.querySelectorAll('.case-card[data-start-time]').forEach(card => {
    const timeEl = card.querySelector('.case-time');
    // data属性から開始時刻を取得
    const startTime = parseInt(card.dataset.startTime, 10);
    
    if (timeEl && startTime) {
      const elapsedMs = now - startTime;
      const totalSeconds = Math.floor(elapsedMs / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      // ミリ秒を100分の1秒単位に変換
      const centiseconds = Math.floor((elapsedMs % 1000) / 10);

      timeEl.textContent = `${minutes}:${String(seconds).padStart(2, '0')}.${String(centiseconds).padStart(2, '0')}`;
    }
  });
  
  // 次の描画フレームで自身を再度呼び出し、ループさせる
  requestAnimationFrame(updateTimers);
}
// ▲▲▲【ここまで追加】▲▲▲

function updateCaseStatus() {
  const el = document.getElementById("caseList");
  if (!scenarioEngine) {
    el.innerHTML = '<div class="no-cases">CSVファイルを読み込んでください</div>';
    return;
  }
  
  const active = scenarioEngine.getVisibleCases();
  if (active.length === 0) {
    el.innerHTML = '<div class="no-cases">現在、進行中の事案はありません</div>';
    return;
  }

  active.sort((a, b) => b.level - a.level);
  el.innerHTML = active.map(c => {
    const t = Math.floor((Date.now() - c.startTime) / 1000);
    const m = Math.floor(t / 60), s = t % 60;
    
    // ★★★ 修正：プライマリとバックアップを区別せず、全ユニットを均等に表示 ★★★
    const allUnits = [c.unit, ...c.backupUnits].filter(u => u); // nullやundefinedを除外
    const unitsStr = allUnits.join('・');
    
    const levelClass = `lv${c.level}`;
    
    return `<div class="case-card" data-start-time="${c.startTime}">
      <div class="case-header">
        <span class="level-badge ${levelClass}">LV${c.level}</span>
        <span class="case-id">${c.id}</span>
        <span class="case-type">${c.scenario.name}</span>
      </div>
      <div class="case-body">
        <div class="case-info-row"><span class="info-label">地区:</span><span class="info-value">${c.zone}</span></div>
        <div class="case-info-row"><span class="info-label">状態:</span><span class="info-value">${c.phase}</span></div>
      </div>
      <div class="case-footer">
        <span class="case-units">${unitsStr}</span>
        <span class="case-time">${m}:${String(s).padStart(2, '0')}</span>
      </div>
    </div>`;
  }).join('');
}


// ==========================================
// ユーティリティ
// ==========================================

const sleep = ms => new Promise(r => setTimeout(r, ms));

async function typeOut(seed, cpsBase, ev, msgEl) {
  const pauses = { ",": 120, "、": 160, ".": 180, "。": 220, " ": 50 };
  const base = 1000 / cpsBase;
  msgEl.textContent = "";

  for (let i = 0; i < ev.message.length; i++) {
    const ch = ev.message[i];
    let extra = pauses[ch] || 0;
    await sleep(base + extra);
    msgEl.textContent += ch;
  }
}

// ==========================================
// 音声関連
// ==========================================

// ▼▼▼【変更点】AudioContextとミキサーの初期化処理をここに集約 ▼▼▼
function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    masterGain = audioCtx.createGain();
    sfxGain = audioCtx.createGain();
    noiseGain = audioCtx.createGain();
    
    sfxGain.connect(masterGain);
    noiseGain.connect(masterGain);
    masterGain.connect(audioCtx.destination);

    // スライダーの初期値を反映
    const masterVol = parseFloat(document.getElementById("masterVolumeSlider").value);
    const sfxVol = parseFloat(document.getElementById("sfxVolumeSlider").value);
    const noiseVol = parseFloat(document.getElementById("noiseVolumeSlider").value);
    
    masterGain.gain.setValueAtTime(masterVol, audioCtx.currentTime);
    sfxGain.gain.setValueAtTime(sfxVol, audioCtx.currentTime);
    noiseGain.gain.setValueAtTime(noiseVol, audioCtx.currentTime);
  }
  if (audioCtx.state === "suspended") {
    audioCtx.resume();
  }
}
// ▲▲▲【変更点】▲▲▲

function playChirp(type) {
  if (!audioCtx) return;
  const t0 = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'triangle';
  gain.gain.value = 0;

  const vol = 0.05; // 基準音量

  if (type === 'start') {
    osc.frequency.setValueAtTime(250, t0 + 0.12);
    gain.gain.linearRampToValueAtTime(vol, t0 + 0.13);
    gain.gain.linearRampToValueAtTime(0, t0 + 0.17);
    osc.frequency.setValueAtTime(750, t0 + 0.06);
    gain.gain.linearRampToValueAtTime(vol, t0 + 0.07);
    gain.gain.linearRampToValueAtTime(0, t0 + 0.11);
  } else if (type === 'end') {
    osc.frequency.setValueAtTime(1500, t0);
    gain.gain.linearRampToValueAtTime(vol, t0 + 0.01);
    gain.gain.linearRampToValueAtTime(0, t0 + 0.05);
    osc.frequency.setValueAtTime(750, t0 + 0.06);
    gain.gain.linearRampToValueAtTime(vol, t0 + 0.07);
    gain.gain.linearRampToValueAtTime(0, t0 + 0.11);
    osc.frequency.setValueAtTime(250, t0 + 0.12);
    gain.gain.linearRampToValueAtTime(vol, t0 + 0.13);
    gain.gain.linearRampToValueAtTime(0, t0 + 0.17);
  }

  osc.connect(gain);
  // ▼▼▼【変更点】接続先をsfxGainミキサーに変更 ▼▼▼
  gain.connect(sfxGain);
  // ▲▲▲【変更点】▲▲▲
  osc.start(t0);
  osc.stop(t0 + 0.2);
}

function startWhiteNoise() {
  if (!audioCtx || whiteNoiseNode) return;
  
  const bufferSize = audioCtx.sampleRate * 1;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const output = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    output[i] = Math.random() * 2 - 1;
  }

  whiteNoiseNode = audioCtx.createBufferSource();
  whiteNoiseNode.buffer = buffer;
  whiteNoiseNode.loop = true;
  
  const gainNode = audioCtx.createGain();
  const lowPassFilter = audioCtx.createBiquadFilter();
  lowPassFilter.type = 'lowpass';
  lowPassFilter.frequency.value = 1500;
  const highPassFilter = audioCtx.createBiquadFilter();
  highPassFilter.type = 'highpass';
  highPassFilter.frequency.value = 500;

  whiteNoiseNode.connect(highPassFilter);
  highPassFilter.connect(lowPassFilter);
  lowPassFilter.connect(gainNode);
  // ▼▼▼【変更点】接続先をnoiseGainミキサーに変更 ▼▼▼
  gainNode.connect(noiseGain);
  // ▲▲▲【変更点】▲▲▲
  
  gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
  // フェードインはここで行う（基準音量まで）
  gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 1);
  
  whiteNoiseNode.start();
}

function stopWhiteNoise() {
  return new Promise(resolve => {
    if (!whiteNoiseNode) {
      resolve();
      return;
    }
    // 即時停止ではなく、フェードアウトさせるために新しいGainNodeを使う
    const fadeOutGain = audioCtx.createGain();
    fadeOutGain.connect(noiseGain); // 接続先はnoiseGainのまま
    
    const currentGain = 0.01; // startWhiteNoiseの最大音量に合わせる
    fadeOutGain.gain.setValueAtTime(currentGain, audioCtx.currentTime);
    fadeOutGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05);

    try {
        whiteNoiseNode.disconnect();
        whiteNoiseNode.connect(fadeOutGain);
    } catch (e) { /* ignore */ }

    setTimeout(() => {
      try {
        whiteNoiseNode.stop();
      } catch (e) { /* ignore */ }
      whiteNoiseNode = null;
      resolve();
    }, 50);
  });
}

function toneNTT(kind) {
  if (!TTS_ENABLED || !audioCtx) return;
  const p = {
    pip: { f: 2000, dur: 4, g: 0.03, atk: 0.001, dec: 0.030, rel: 0.030, h2: 0.3 },
    pop: { f: 500, dur: 100, g: 0.06, atk: 0.001, dec: 0.050, rel: 0.060, h2: 1 },
    peen: { f: 1000, dur: 600, g: 0.06, atk: 0.003, dec: 0.01, rel: 0.003, h2: 1 }
  }[kind];

  const ctx = audioCtx, t0 = ctx.currentTime;
  const osc = ctx.createOscillator(); osc.type = 'square'; osc.frequency.value = p.f;
  const gain = ctx.createGain(); gain.gain.value = 0;
  const filter = ctx.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = p.f * 1.4;
  osc.connect(filter); filter.connect(gain);
  // ▼▼▼【変更点】接続先をsfxGainミキサーに変更 ▼▼▼
  gain.connect(sfxGain);
  // ▲▲▲【変更点】▲▲▲

  const g = gain.gain;
  g.setValueAtTime(0, t0);
  g.linearRampToValueAtTime(p.g, t0 + p.atk);
  g.linearRampToValueAtTime(p.g * 0.8, t0 + p.atk + p.dec);
  g.linearRampToValueAtTime(0.0001, t0 + (p.dur / 1000) + p.rel);

  osc.start(t0);
  osc.stop(t0 + (p.dur / 1000) + p.rel + 0.05);
}
// ▼▼▼【変更】引数にshowOverlayを追加 ▼▼▼
function playEmergencyBeep(durationMs, showOverlay = true) {
  if (!TTS_ENABLED || !audioCtx) return Promise.resolve();
  ensureAudio();

  // ▼▼▼【変更】showOverlayがtrueの時のみ警告画面を表示 ▼▼▼
  const overlay = document.getElementById('emergency-overlay');
  if (showOverlay) {
    overlay.classList.add('active');
  }
  // ▲▲▲【変更】ここまで ▲▲▲

  return new Promise(resolve => {
    const t0 = audioCtx.currentTime;
    const durationSec = durationMs / 1000;

    const mainGain = audioCtx.createGain();
    mainGain.connect(sfxGain);
    mainGain.gain.value = 0;

    const osc1 = audioCtx.createOscillator();
    const osc2 = audioCtx.createOscillator();
    osc1.type = 'sine';
    osc2.type = 'sine';
    osc1.frequency.setValueAtTime(1000, t0);
    osc2.frequency.setValueAtTime(1030, t0);
    osc1.connect(mainGain);
    osc2.connect(mainGain);

    const attackTime = 0.005;
    const releaseTime = 0.01;
    const vol = 0.02; // 基準音量
    mainGain.gain.linearRampToValueAtTime(vol, t0 + attackTime);
    mainGain.gain.setValueAtTime(vol, t0 + durationSec - releaseTime);
    mainGain.gain.linearRampToValueAtTime(0, t0 + durationSec);

    osc1.start(t0);
    osc2.start(t0);
    osc1.stop(t0 + durationSec);
    osc2.stop(t0 + durationSec);

    osc2.onended = () => {
      // ▼▼▼【変更】showOverlayがtrueの時のみ警告画面を非表示 ▼▼▼
      if (showOverlay) {
        overlay.classList.remove('active');
      }
      // ▲▲▲【変更】ここまで ▲▲▲
      resolve();
    };
  });
}
function startTimeSignal() {
  if (tickTimer) clearTimeout(tickTimer);
  if (!TTS_ENABLED) return;
  ensureAudio();

  const tick = () => {
    if (!TTS_ENABLED) { 
      tickTimer = null;
      return;
    }
    const s = new Date().getSeconds();
    if (s % 10 === 0) { toneNTT('peen'); }
    else if (s >= 57) { toneNTT('pop'); }
    else { toneNTT('pip'); }
    const delay = 1000 - new Date().getMilliseconds();
    tickTimer = setTimeout(tick, delay);
  };
  const firstDelay = 1000 - new Date().getMilliseconds();
  tickTimer = setTimeout(tick, firstDelay);
}

function stopTimeSignal() {
  if (tickTimer) {
    clearTimeout(tickTimer);
    tickTimer = null;
  }
}

// ==========================================
// 時計
// ==========================================
(function () {
  const el = document.getElementById("jst");
  function pad(n, len = 2) { return String(n).padStart(len, "0"); }
  function tick() {
    const now = new Date();
    const ms = String(now.getMilliseconds()).padStart(3, '0');
    el.textContent = `${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}.${ms}`;
  }
  tick();
  setInterval(tick, 50);
})();

// ==========================================
// 自動スクロール制御
// ==========================================
(function() {
  const log = document.getElementById("log");
  let scrollAnimationFrame = null;
  const SCROLL_SPEED = 0.5; // ピクセル/フレーム（この値を調整して速度変更）
  let userScrolling = false;
  let scrollTimeout = null;
  let isAutoScrolling = false;
 
  function smoothScrollToBottom() {
    if (userScrolling) return;
    
    isAutoScrolling = true;
    const targetScroll = log.scrollHeight - log.clientHeight;
    const currentScroll = log.scrollTop;
    const distance = targetScroll - currentScroll;
   
    if (Math.abs(distance) < 1) {
      log.scrollTop = targetScroll;
      scrollAnimationFrame = null;
      isAutoScrolling = false;
      return;
    }
   
    // 一定速度でスクロール（速度は固定）
    log.scrollTop = currentScroll + Math.min(SCROLL_SPEED, distance);
   
    scrollAnimationFrame = requestAnimationFrame(smoothScrollToBottom);
  }
 
  function resetAutoScroll() {
    userScrolling = false;
    if (scrollAnimationFrame) {
      cancelAnimationFrame(scrollAnimationFrame);
    }
   
    // 速度計算せず、固定速度でスクロール開始
    smoothScrollToBottom();
  }
  
  // 新しいログが追加されたときの処理
  const observer = new MutationObserver(() => {
    // ユーザーがスクロール中でなく、かつ既に自動スクロール中なら継続
    // ユーザーがスクロール中でなく、自動スクロールもしていなければ開始
    if (!userScrolling && !scrollAnimationFrame) {
      smoothScrollToBottom();
    }
    // 既にスクロール中なら何もしない（固定速度を維持）
  });
  
  observer.observe(log, { childList: true, subtree: true });
 
  log.addEventListener('wheel', () => {
    userScrolling = true;
    clearTimeout(scrollTimeout);
    if (scrollAnimationFrame) {
      cancelAnimationFrame(scrollAnimationFrame);
      scrollAnimationFrame = null;
    }
    isAutoScrolling = false;
    scrollTimeout = setTimeout(resetAutoScroll, 5000);
  });
 
  // touchstartでは userScrolling = true にしない！
  log.addEventListener('touchstart', (e) => {
    touchStartY = e.touches[0].clientY;
    hasMoved = false;
    // userScrolling はここで設定しない
  });

  // touchmoveで実際にスクロールした時だけ設定
  log.addEventListener('touchmove', (e) => {
    if (実際にスクロールした) {
      userScrolling = true;  // ← ここで初めて設定
    }
  });

  // touchendでスクロールしていない場合は何もしない
  log.addEventListener('touchend', () => {
    if (hasMoved) {  // ← スクロールした場合のみ
      scrollTimeout = setTimeout(resetAutoScroll, 5000);
    }
    // スクロールしてなければ自動スクロール継続
  });
 
  log.addEventListener('mouseup', () => {
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(resetAutoScroll, 5000);
  });
})();
// ==========================================
// 音声合成（TTS）
// ==========================================

function loadVoices() {
  if (!('speechSynthesis' in window)) return;
  const load = () => {
    const vs = speechSynthesis.getVoices();
    const sel = document.getElementById("voiceSel");
    sel.innerHTML = '<option value="">声の種類</option>';
    vs.forEach((v, i) => {
      const o = document.createElement('option');
      o.value = String(i); o.textContent = `${v.name} (${v.lang})`;
      sel.appendChild(o);
    });
    const jaVoice = vs.find(v => /^ja/i.test(v.lang)) || vs[0];
    chosenVoice = jaVoice;
  };
  load();
  speechSynthesis.onvoiceschanged = load;
}
loadVoices();
async function speakMessage(text, isTest = false) {
  // ▼▼▼【修正】Promiseの引数に reject を追加 ▼▼▼
  return new Promise((resolve, reject) => {
    // 50ms待機
    setTimeout(() => {
      if (!('speechSynthesis' in window)) {
        // 音声合成が利用できない場合は即時完了させる
        resolve();
        return;
      }

      const masterVol = masterGain ? masterGain.gain.value : parseFloat(document.getElementById("masterVolumeSlider").value);
      const utter = new SpeechSynthesisUtterance(text);
      
      utter.voice = chosenVoice;
      utter.rate = ttsRate;
      utter.volume = ttsVolume * masterVol;
      
      // ▼▼▼【重要】読み上げ完了時にPromiseを解決する ▼▼▼
      utter.onend = resolve;
      // ▼▼▼【重要】エラー発生時にもPromiseを完了させる ▼▼▼
      // ▼▼▼【修正】エラーの種類を判別する ▼▼▼
      utter.onerror = (e) => {
        // 'interrupted' はユーザーによるキャンセルなので、エラー扱いにせず正常終了とする
        if (e.error === 'interrupted') {
          resolve();
        } else {
          // それ以外のエラーはコンソールに表示してエラー終了とする
          console.error("SpeechSynthesisUtterance.onerror", e);
          reject(e);
        }
      };
      
      // さらに50ms待機してからspeak()
      setTimeout(() => {
        speechSynthesis.speak(utter);
      }, 50);
    }, 50);
  });
}

/// ==========================================
// メインループ
// ==========================================
async function runSystem() {
  if (!scenarioEngine) {
    alert('CSVファイルを先に読み込んでください');
    return;
  }
  const status = document.getElementById("status");
  const log = document.getElementById("log");
  const my = ++runningToken;
  log.innerHTML = "";
  scenarioEngine.activeCases.clear();
  scenarioEngine.caseIdCounter = 1;
  scenarioEngine.nodeIdCounter = 1;
  // システム開始時にbackup-all状態をリセット
  if (scenarioEngine) {
    scenarioEngine.isBackupAllActive = false;
    scenarioEngine.backupAllCaseId = null;
  }
  status.textContent = "ACTIVE";
  
  let pendingResponseCaseId = null; 

  async function processAndDisplayEvent(event) {
  if (!event) return;
  
  const caseObj = scenarioEngine.activeCases.get(event.caseId);
  const isNewCase = caseObj && !caseObj.isVisible;

  // ★★★ 修正：新規事案の場合は、メッセージ表示前にCasePanelを更新しない ★★★
  if (!isNewCase) {
      updateCaseStatus();
  }

  const row = document.createElement("div");
  row.className = "radio-message";
  if (event.params && event.params.alert === 'beep') {
    row.classList.add('alert');
  }
  const meta = document.createElement("div");
  meta.className = "radio-message-meta";
  const ts = document.createElement("div");
  ts.className = "msg-time";
  const ts_now = new Date();
  ts.textContent = ts_now.toLocaleTimeString("ja-JP", { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
  const ch = document.createElement("div");
  ch.className = `msg-level lv${event.level}`;
  ch.textContent = `LV${event.level}`;
  const caseTag = document.createElement("div");
  caseTag.className = "msg-case";
  caseTag.textContent = event.caseId;
  meta.append(ts, ch, caseTag);
  const msg = document.createElement("div");
  msg.className = "msg-content";
  row.append(meta, msg);
  log.appendChild(row);

  if (event.params && event.params.alert === 'beep' && TTS_ENABLED) {
      await playEmergencyBeep(3000);
      await sleep(500);
  }
  if (TTS_ENABLED) {
    ensureAudio();
    playChirp('start');
    startWhiteNoise();
  }
  
  // ★★★ 削除：ここでisNewCaseの処理をしない（メッセージ表示後に移動）★★★
  // if (isNewCase) {
  //     caseObj.isVisible = true;
  //     updateCaseStatus();
  // }

  // ★★★ メッセージ表示（typeOut + TTS） ★★★
  if (TTS_ENABLED) {
    await Promise.all([
      typeOut("", BASE_CPS, event, msg),
      speakMessage(event.message)
    ]);
  } else {
    await typeOut("", BASE_CPS, event, msg);
  }
  if (TTS_ENABLED) {
    await stopWhiteNoise();
    playChirp('end');
  }

  // ★★★ 追加：メッセージ表示完了後に新規事案をCasePanelに表示 ★★★
  if (isNewCase) {
      caseObj.isVisible = true;
      updateCaseStatus();
  }

  if (event.params && event.params['need-response'] === 'true') {
      pendingResponseCaseId = event.caseId;
  }

  // ★★★ 追加：既存事案の場合もメッセージ表示後にCasePanelを更新 ★★★
  // （backup-all途中発令などで変更があった場合に反映）
  if (!isNewCase) {
      updateCaseStatus();
  }

  // --- backup-all状態の解除ロジック ---
  if (event.params && event.params.clear === 'true') {
    // 完了した事案が「backup-all」を発令した事案かどうかを確認
    if (scenarioEngine.isBackupAllActive && event.caseId === scenarioEngine.backupAllCaseId) {
      // 「発出済みのbackup_unit事件を解決してから」のロジック
      // 状態を解除し、他の事案が応援を呼べるようにする
      scenarioEngine.isBackupAllActive = false;
      scenarioEngine.backupAllCaseId = null;
    }
    scenarioEngine.activeCases.delete(event.caseId);
    updateCaseStatus(); 
  }
  
  const randomDelay = Math.random() * 4000 + 2000;
  await sleep(randomDelay);
}

  updateCaseStatus();

  while (my === runningToken) {
    let eventToProcess = null;
    const busyUnits = new Set();
    for (const caseObj of scenarioEngine.activeCases.values()) {
        busyUnits.add(caseObj.unit);
        busyUnits.add(...caseObj.backupUnits);
    }
    
    if (pendingResponseCaseId) {
      eventToProcess = scenarioEngine.progressCase(pendingResponseCaseId, busyUnits);
      if (eventToProcess) {
        pendingResponseCaseId = null;
      }
    } 
    
    if (!eventToProcess) {
      const activeCases = scenarioEngine.getVisibleCases();
      const activeCaseCount = activeCases.length;

      if (activeCaseCount < 5 && Math.random() < 0.5) {
        eventToProcess = scenarioEngine.generateNewCase(busyUnits);
      }

      if (!eventToProcess && activeCaseCount > 0) {
        let caseIdToProgress = null;
        activeCases.sort((a, b) => a.startTime - b.startTime);
        
        const oldestCase = activeCases[0];
        const otherCases = activeCases.slice(1);

        if (Math.random() < 0.5) {
          caseIdToProgress = oldestCase.id;
        } else {
          if (otherCases.length > 0) {
            const randomOtherCase = otherCases[Math.floor(Math.random() * otherCases.length)];
            caseIdToProgress = randomOtherCase.id;
          } else {
            caseIdToProgress = oldestCase.id;
          }
        }
        
        if (caseIdToProgress) {
            eventToProcess = scenarioEngine.progressCase(caseIdToProgress, busyUnits);
        }
      }
    }

    if (eventToProcess) {
      await processAndDisplayEvent(eventToProcess);
    } else {
      updateCaseStatus();
      await sleep(1000); 
    }
  }
}

// ==========================================
// イベントリスナー
// ==========================================
function initializeSystem(csvText) {
    scenarioLoader = new ScenarioLoader();
    scenarioLoader.parseCSV(csvText);
    const unitTypes = {
        investigation: scenarioLoader.paramLists.units_investigation || [],
        traffic: scenarioLoader.paramLists.units_traffic || [],
        patrol: scenarioLoader.paramLists.units_patrol || [],
        backup: scenarioLoader.paramLists.units_backup || []
    };
    scenarioEngine = new ScenarioEngine(scenarioLoader, unitTypes);
    document.getElementById("syncBtn").disabled = false;
    document.getElementById("caseList").innerHTML = '<div class="no-cases">✅ シナリオ読込完了。システムを起動してください</div>';
}

window.addEventListener('DOMContentLoaded', async () => {
  const commanderInput = document.getElementById("commanderInput");
  const systemTitle = document.getElementById("systemTitle");
  commanderInput.addEventListener('input', (e) => {
    const newName = e.target.value.trim();
    commanderName = newName || "本部";
    systemTitle.textContent = `${commanderName}通信指令観測システム`;
  });
  systemTitle.textContent = `${commanderInput.value.trim()}通信指令観測システム`;

  try {
    const response = await fetch('scenario.csv');
    if (response.ok) {
      const csvText = await response.text();
      initializeSystem(csvText);
    } else {
      document.getElementById("caseList").innerHTML = '<div class="no-cases">❌ scenario.csvの読込に失敗しました。</div>';
    }
  } catch (fetchError) {
    document.getElementById("caseList").innerHTML = '<div class="no-cases">❌ scenario.csvの読込に失敗しました。</div>';
  }

  document.getElementById("toggleControls").addEventListener("click", () => {
    document.getElementById("controlPanel").classList.toggle("is-open");
  });

  document.getElementById("closeControlsBtn").addEventListener("click", () => {
    document.getElementById("controlPanel").classList.remove("is-open");
  });

  document.getElementById("voiceSel").addEventListener('change', () => {
    const vs = speechSynthesis.getVoices();
    const i = parseInt(document.getElementById("voiceSel").value);
    chosenVoice = Number.isInteger(i) ? vs[i] : vs.find(v => /^ja/i.test(v.lang));
  });

  const rateSlider = document.getElementById("rateSlider");
  rateSlider.addEventListener('input', (e) => {
    ttsRate = parseFloat(e.target.value);
    document.getElementById("rateValue").textContent = ttsRate.toFixed(1);
  });
  rateSlider.addEventListener('change', () => {
    // マウスを離した時に速度テスト音声を再生
    if ('speechSynthesis' in window) {
      speechSynthesis.cancel(); // 既存の音声を停止
      speakMessage("速度テスト", true); // isTestフラグを立てて再生
    }
  });
  // ▼▼▼【変更点】音量スライダーのイベントリスナーを修正 ▼▼▼
  document.getElementById("masterVolumeSlider").addEventListener('input', (e) => {
    const vol = parseFloat(e.target.value);
    document.getElementById("masterVolumeValue").textContent = vol.toFixed(2);
    if (masterGain) {
      // setTargetAtTimeで急な音量変化によるノイズ（プツッ音）を防ぐ
      masterGain.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.01);
    }
  });

  const sfxSlider = document.getElementById("sfxVolumeSlider");
  sfxSlider.addEventListener('input', (e) => {
    const vol = parseFloat(e.target.value);
    document.getElementById("sfxVolumeValue").textContent = vol.toFixed(2);
    if (sfxGain) {
      sfxGain.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.01);
    }
  });
  sfxSlider.addEventListener('change', () => {
    // マウスを離した時に警報Beepを1秒流す（警報画面なし）
    ensureAudio();
    playEmergencyBeep(1000, false); // ▼▼▼【変更】第2引数にfalseを追加 ▼▼▼
  });

  document.getElementById("noiseVolumeSlider").addEventListener('input', (e) => {
    const vol = parseFloat(e.target.value);
    document.getElementById("noiseVolumeValue").textContent = vol.toFixed(2);
    if (noiseGain) {
      noiseGain.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.01);
    }
  });
  
  // TTSスライダーは操作中(input)ではなく、完了後(change)にイベントを発火
  const ttsSlider = document.getElementById("ttsVolumeSlider");
  ttsSlider.addEventListener('input', (e) => {
    const vol = parseFloat(e.target.value);
    document.getElementById("ttsVolumeValue").textContent = vol.toFixed(2);
    ttsVolume = vol; // 値はリアルタイムで更新
  });
  ttsSlider.addEventListener('change', () => {
    // マウスを離した時にテスト音声を再生
    if ('speechSynthesis' in window) {
      speechSynthesis.cancel(); // 既存の音声を停止
      speakMessage("音量テスト", true); // isTestフラグを立てて再生
    }
  });
  
  // 初期値のUI反映
  document.getElementById("masterVolumeValue").textContent = parseFloat(document.getElementById("masterVolumeSlider").value).toFixed(2);
  document.getElementById("ttsVolumeValue").textContent = parseFloat(ttsSlider.value).toFixed(2);
  document.getElementById("sfxVolumeValue").textContent = parseFloat(document.getElementById("sfxVolumeSlider").value).toFixed(2);
  document.getElementById("noiseVolumeValue").textContent = parseFloat(document.getElementById("noiseVolumeSlider").value).toFixed(2);
  ttsVolume = parseFloat(ttsSlider.value); // 初期値を反映
  updateTimers();
  // ▲▲▲【変更点】▲▲▲

  const initialSliders = [
    document.getElementById("rateSlider").parentElement,
    document.getElementById("masterVolumeSlider").parentElement,
    document.getElementById("ttsVolumeSlider").parentElement,
    document.getElementById("sfxVolumeSlider").parentElement,
    document.getElementById("noiseVolumeSlider").parentElement,
    document.getElementById("voiceSel")
  ];
  initialSliders.forEach(el => el.classList.add('disabled'));
  

});

document.getElementById("syncBtn").addEventListener("click", () => {
  // ▼▼▼【追加】現在再生中の音声をすべて停止する ▼▼▼
  if ('speechSynthesis' in window) {
    speechSynthesis.cancel();
  }
  // ▲▲▲【追加】ここまで ▲▲▲

  if (TTS_ENABLED) {
    startTimeSignal();
  }
  runSystem();
});

function toggleTTS() {
  TTS_ENABLED = !TTS_ENABLED;
  
  // 両方のボタンを更新
  const btn1 = document.getElementById("ttsToggle");
  const btn2 = document.getElementById("ttsToggle2");
  const text = `音声: ${TTS_ENABLED ? "ON" : "OFF"}`;
  const className = TTS_ENABLED ? "btn active" : "btn";
  
  btn1.textContent = text;
  btn1.className = className;
  btn2.textContent = text;
  btn2.className = className;
  
  // スライダーの有効/無効を切り替え
  const sliders = [
    document.getElementById("rateSlider").parentElement,
    document.getElementById("masterVolumeSlider").parentElement,
    document.getElementById("ttsVolumeSlider").parentElement,
    document.getElementById("sfxVolumeSlider").parentElement,
    document.getElementById("noiseVolumeSlider").parentElement,
    document.getElementById("voiceSel")
  ];
  
  sliders.forEach(el => {
    if (TTS_ENABLED) {
      el.classList.remove('disabled');
    } else {
      el.classList.add('disabled');
    }
  });
  
  if (TTS_ENABLED) {
    ensureAudio();
    startTimeSignal();
  } else {
    stopTimeSignal();
    if ('speechSynthesis' in window) {
        speechSynthesis.cancel();
    }
  }
}

// 両方のボタンに同じ関数を割り当て
document.getElementById("ttsToggle").addEventListener("click", toggleTTS);
document.getElementById("ttsToggle2").addEventListener("click", toggleTTS);

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./service-worker.js')
      .then(reg => console.log('Service Worker registered'))
      .catch(err => console.log('Service Worker registration failed'));
  });
}

</script>
</body>
</html>